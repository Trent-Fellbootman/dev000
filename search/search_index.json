{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DEV-000: The Complete Introduction to Development","text":""},{"location":"#this-project-is-currently-under-construction","title":"THIS PROJECT IS CURRENTLY UNDER CONSTRUCTION","text":"<p>This course provides a complete introduction to programming, computers and software development and covers various topics such as:</p> <ul> <li>Programming Languages</li> <li>Terminal &amp; Unix</li> <li>Concurrency</li> <li>Software Design &amp; Project Development</li> <li>Computer Hardware Fundamentals</li> <li>AI Aided Development &amp; AI Application Development</li> </ul>"},{"location":"outline/","title":"DEV-000 Course Structure","text":"<p>Preface: Course goal? What do you need to know to be a \"true developer\"? How to learn this course?</p> <ul> <li>Don't try to learn a \"specific language\"; consult GPT when you have difficulties.</li> </ul>"},{"location":"outline/#module-0-the-abstraction-of-a-computer","title":"Module 0: The Abstraction of a Computer","text":"<ul> <li>Address space &amp; memory</li> <li>Machine code &amp; compiling</li> </ul>"},{"location":"outline/#module-1-programming","title":"Module 1: Programming","text":""},{"location":"outline/#how-do-programming-languages-work","title":"How do programming languages work?","text":""},{"location":"outline/#programming-fundamentals-also-mention-common-semantics-coding-practices","title":"Programming Fundamentals (Also mention common semantics &amp; coding practices)","text":"<ul> <li>variables &amp; types</li> <li>control flow statements</li> <li>functions</li> <li>classes</li> <li>modules</li> </ul>"},{"location":"outline/#programming-language-taxonomy","title":"Programming Language Taxonomy","text":"<ul> <li>Compiled Languages v.s. Interpreted Languages + virtual-machine-based</li> <li>Static typing v.s. Dynamic typing</li> <li>Garbage collection v.s. manual resource management</li> <li>High-level v.s. low-level</li> </ul>"},{"location":"outline/#common-concepts-in-programming-languages","title":"Common Concepts in Programming Languages","text":"<ul> <li>Abstraction</li> <li>Interfaces &amp; ABCs &amp; Polymorphism</li> <li>Meta-programming</li> <li>find-replace-based macros</li> <li>generics</li> <li>Ownership &amp; lifetimes</li> <li>Error Handling</li> <li>try-catch</li> <li>Result</li> </ul>"},{"location":"outline/#other-abnormal-languages","title":"Other \"Abnormal\" Languages","text":"<ul> <li>LISP</li> </ul>"},{"location":"outline/#how-to-code-properly","title":"How to code properly?","text":""},{"location":"outline/#common-coding-practices","title":"Common Coding Practices","text":"<ul> <li>Code Styling</li> <li>CODE_OF_CONDUCT</li> <li>Identifiers Naming Conventions</li> <li>Comments &amp; docstrings</li> <li>Testing (just mention some concepts)</li> </ul>"},{"location":"outline/#programming-principles","title":"Programming Principles","text":"<ul> <li>Syntax &amp; Semantics: What it can be v.s. What it should be (and usually be)</li> <li>Don't repeat yourself</li> <li>The rule of elegance</li> <li>Hierarchy</li> <li>Coupling &amp; Cohesion</li> <li>Depend on interfaces, not implementations</li> <li>Write comments</li> <li>When the program is short, forget about all principles</li> </ul>"},{"location":"outline/#programming-paradigms","title":"Programming Paradigms","text":"<ul> <li>Object Oriented Programming</li> <li>Functional Programming</li> </ul>"},{"location":"outline/#designing-software-systems-preliminary","title":"Designing Software Systems (preliminary)","text":"<ul> <li>Modules &amp; APIs</li> <li>Coupling &amp; Cohesion</li> </ul>"},{"location":"outline/#how-do-computer-programs-run-under-the-hood","title":"How do computer programs run under the hood?","text":""},{"location":"outline/#module-2-terminal-unix-basics","title":"Module 2: Terminal &amp; Unix Basics","text":""},{"location":"outline/#terminal-shell-scripting","title":"Terminal &amp; Shell Scripting","text":"<ul> <li>What is a terminal? What is a shell? What is a shell script?</li> <li>Taxonomy of shell scripting languages: text-based (bash) v.s. data-oriented (powershell &amp; nushell)</li> <li>Key differences between scripting languages and programming languages</li> <li>Shell scripting basics</li> <li>Basic commands<ul> <li>cd, pwd, pushd, popd, find, ...</li> </ul> </li> <li>variables &amp; control flows, etc.</li> <li>commands</li> <li>pipes &amp; redirection</li> <li>environment variables</li> <li>Miscellaneous<ul> <li>&amp;&amp;, ;, $!, ...</li> </ul> </li> <li>Terminal Tricks &amp; Common Practices</li> <li>Auto-completion, history, etc.</li> <li>Shell config files</li> <li>Prompt-customization &amp; theming</li> <li>Shell plugins</li> <li>Common Tools &amp; Commands<ul> <li>grep, cut, awk, tmux, ssh, etc.</li> </ul> </li> </ul>"},{"location":"outline/#package-management","title":"Package Management","text":"<ul> <li>Software dependencies</li> <li>Software packages</li> <li>Package managers</li> </ul>"},{"location":"outline/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Config files</li> <li>vim &amp; emacs</li> <li>Virtualization &amp; docker</li> <li>Booting</li> <li>Hard drive partitions &amp; (g)parted</li> <li>Bootloaders &amp; GRUB</li> <li>BIOS &amp; UEFI</li> <li>Dual (Multi) Booting</li> <li>Linux potpourri</li> <li>kernel modules</li> </ul>"},{"location":"outline/#module-3-software-systems-development","title":"Module 3: Software Systems Development","text":""},{"location":"outline/#common-concepts-in-software-systems","title":"Common Concepts in Software Systems","text":"<ul> <li>Versioning &amp; Dependencies</li> <li>Semantic Versioning</li> <li>Interfaces &amp; APIs &amp; Libraries</li> <li>Remote Procedure Call (RPC)</li> <li>Serialization &amp; Deserialization</li> <li>Inter-process communication (IPC)</li> <li>Frameworks</li> <li>What is a framework? Why framework?</li> <li>Framework v.s. Library</li> <li>Examples: Flutter (UI), PyTorch (deep learning) &amp; Unity (game development)</li> <li>Specification &amp; Standards (Use examples to illustrate the concept)</li> <li>Why standards?</li> <li>Examples<ul> <li>CPU Instruction Set Architectures (ISAs)</li> <li>GPU specifications (OpenGL &amp; Vulkan)</li> <li>Data Representation Standards (JSON, TOML, YAML, XML, HTML)</li> </ul> </li> </ul>"},{"location":"outline/#designing-software-systems","title":"Designing Software Systems","text":"<ul> <li>Modules &amp; APIs &amp; Interfaces</li> <li>Coupling &amp; Cohesion</li> <li>Software System Design Principles (In addition to programming principles)</li> <li>Abstract your dependencies</li> </ul>"},{"location":"outline/#testing","title":"Testing","text":"<ul> <li>Unit testing</li> </ul>"},{"location":"outline/#documentation","title":"Documentation","text":"<ul> <li>Docstrings</li> <li>API Docs</li> <li>Tutorials</li> <li>Doctests</li> <li>Common documentation frameworks &amp; languages</li> <li>Sphinx &amp; mkdocs (just mention)</li> <li>Markdown &amp; RST</li> </ul>"},{"location":"outline/#building-deployment-tentative","title":"Building &amp; Deployment (tentative)","text":"<ul> <li>Build systems</li> </ul>"},{"location":"outline/#version-control","title":"Version Control","text":"<ul> <li>Version control &amp; git</li> </ul>"},{"location":"outline/#standardization-collaboration","title":"Standardization &amp; Collaboration","text":"<ul> <li>The need for standardization across contributors</li> <li>CODE_OF_CONDUCT</li> </ul>"},{"location":"outline/#cicd","title":"CI/CD","text":""},{"location":"outline/#miscellaneous_1","title":"Miscellaneous","text":"<ul> <li>PRs &amp; Issues</li> <li>README, CONTRIBUTE, LICENSE</li> <li>TODOs &amp; FIXMEs</li> </ul>"},{"location":"outline/#module-4-concurrent-programming-tentative-structure","title":"Module 4: Concurrent Programming (Tentative Structure)","text":""},{"location":"outline/#introduction-to-concurrency","title":"Introduction to Concurrency","text":""},{"location":"outline/#concurrency-model","title":"Concurrency Model","text":"<ul> <li>Concurrency v.s. parallelism</li> </ul>"},{"location":"outline/#problems-with-concurrency","title":"Problems with Concurrency","text":"<ul> <li>Data races</li> </ul>"},{"location":"outline/#low-level-concurrent-programming","title":"Low-level concurrent programming","text":""},{"location":"outline/#synchronization-primitives","title":"Synchronization primitives","text":"<ul> <li>Locks (Mutexes)</li> <li>Semaphores</li> <li>Read-Write Locks</li> </ul>"},{"location":"outline/#concurrent-programming-paradigms","title":"Concurrent Programming Paradigms","text":""},{"location":"outline/#channels","title":"Channels","text":""},{"location":"outline/#producer-consumer","title":"Producer &amp; Consumer","text":""},{"location":"outline/#asynchronous-programming","title":"Asynchronous Programming","text":"<ul> <li>Futures &amp; poll</li> <li>async &amp; await</li> </ul>"},{"location":"outline/#module-5-computer-architecture-fundamentals","title":"Module 5: Computer Architecture Fundamentals","text":""},{"location":"outline/#cpus","title":"CPUs","text":"<ul> <li>Pipelines</li> <li>Memory Hierarchy</li> <li>Branch Prediction &amp; Speculative Execution</li> <li>Out of order processing</li> <li>Vector instructions &amp; SIMD</li> </ul>"},{"location":"outline/#gpus-accelerators","title":"GPUs &amp; Accelerators","text":""},{"location":"outline/#module-6-miscellaneous-topics-in-the-developers-world","title":"Module 6: Miscellaneous Topics in the Developer's World","text":""},{"location":"outline/#ui-app-development","title":"UI &amp; App Development","text":"<ul> <li>Declarative UI v.s. Imperative U</li> </ul>"},{"location":"outline/#game-development","title":"Game Development","text":"<ul> <li>Entity Component System (ECS)</li> </ul>"},{"location":"outline/#gpu-programming","title":"GPU Programming","text":"<ul> <li>High-level: OpenGL</li> <li>Low-level: Vulkan</li> </ul>"},{"location":"outline/#miscellaneous_2","title":"Miscellaneous","text":"<ul> <li>Stackoverflow</li> <li>GitHub</li> <li>IDEs</li> <li>LSPs</li> <li>Hugging Face</li> </ul>"},{"location":"outline/#module-7-ai-aided-development-ai-software-development","title":"Module 7: AI Aided Development &amp; AI Software Development","text":""},{"location":"outline/#artificial-intelligence-basics","title":"Artificial Intelligence Basics","text":"<ul> <li>Deep learning fundamentals</li> <li>Abstracting deep neural networks &amp; AI services for developers</li> </ul>"},{"location":"outline/#ai-aided-development","title":"AI Aided Development","text":"<ul> <li>Code-completion</li> <li>AI Code Generation (logic code, unit tests, documentation, etc.)</li> <li>Auto internationalization</li> <li>AI as an augmented Google</li> </ul>"},{"location":"outline/#ai-software-development","title":"AI Software Development","text":""},{"location":"outline/#a-change-of-mindset-how-is-this-different-from-traditional-software-development","title":"A Change of Mindset: How is this different from \"traditional software development\"?","text":"<ul> <li>Determinism -&gt; Non-deterministic behavior</li> <li>Structured Data -&gt; Natural Language</li> <li>AI involved control flows</li> <li>Short latency -&gt; long-running operations</li> <li>Error Handling &amp; How to ensure robustness when there is AI</li> </ul>"},{"location":"outline/#paradigms-common-practices-at-present","title":"Paradigms &amp; Common Practices at Present","text":"<ul> <li>AI Agents</li> <li>Retrieval Augmented Generation (RAG) &amp; Vector Databases</li> <li>Prompt Engineering &amp; Prompt templates</li> </ul>"},{"location":"abstraction/","title":"Module 1: Abstractions","text":""},{"location":"abstraction/abstraction-intro/","title":"Abstraction: The Developer's Way of Thinking","text":"<p>Before diving into \"developer stuff\" like programming languages, it is important to first understand the idea of abstraction, which is a fundamental concept underlying all software systems, hardware architectures, and essentially, all complicated things.</p> <p>Abstraction helps to manage the complexity of real world systems, to break down complex systems into simpler components and to allow both the creator and non-creators something to quickly understand \"what this thing is\". Abstraction is found in almost every aspect in the modern world, from software applications to hardware and even \"non-technical\" industries such as animated films. However, it is especially important to developers as they deal with and use this concept every day. Essentially, abstraction should be the second instinct of all developers.</p>"},{"location":"abstraction/abstraction-intro/#what-is-abstraction","title":"What is \"Abstraction\"?","text":"<p>Generally speaking, \"to abstract\" roughly means \"to define what something is to someone, disregarding all irrelevant information\".</p> <p>According to the definition above, there are two important questions to ask when abstracting something:</p> <ol> <li>What is this thing?</li> <li>What information are relevant? What information are not? I.e., What does that \"someone\" need to know about?</li> </ol> <p>Notice that both of these questions are dependent to the \"target audience\" of the abstraction, i.e., the person (or the system) that will use the abstraction. If your audience changes, the \"thing\" might look different, relevant information might become irrelevant, and vice versa.</p> <p>Abstraction is not meant for other people only; sometimes (actually most of the time), the target audience will be yourself who is designing and implementing the thing to be abstracted.</p> <p>Although I gave a definition above, abstraction itself is an \"abstract\" idea which is very hard to define clearly, and there is no broadly-accepted definition. So, I will use an example to illustrate what abstraction really means.</p>"},{"location":"abstraction/abstraction-intro/#an-example-of-abstraction","title":"An Example of Abstraction","text":"<p>When you're in a morning rush and you see a car, what first comes to your mind? Is it \"I can drive this thing around\", or chasis, engine, tires and fuel tanks?</p> <p>I believe most people's view would be the former. Of course, the latter view is also important, but it is irrelevant to you at the moment: you're in a rush, so all that matters to you is that you can drive a car to get to your workplace fast.</p> <p>Believe it or not, you have already used abstraction in the example above. Let's break it down a little:</p> <ul> <li>Target of abstraction: The car.</li> <li>Target audience: You.</li> <li>What is this thing: Something you can use to drive around and get to anywhere fast.</li> <li>Relevant information: You can drive this thing around. It's fast.</li> <li>Irrelevant information: It's made up of an engine, a fuel tank, a chasis, etc. It's 4.6 meters long and 1.6 meters tall, with a peak power output of 140 hp. Stuff like that.</li> </ul> <p>The explanation above should be easy to understand: the target audience is you, and the only thing you need to know is that you can drive a car around, so that's the abstraction.</p> <p>For workers at a car factory, however, the view would be different. The workers build cars; they do not need to know how to drive the car, but they do need to know the inner workings of car so that they can build it. This time, the abstraction becomes:</p> <ul> <li>Target of abstraction: The car.</li> <li>Target audience: Factory workers.</li> <li>What is this thing: A car is made of an engine, a fuel tank, a chasis and a bunch of other stuff.</li> <li>Relevant information: Internal structures of a car.</li> <li>Irrelevant information: How to drive a car.</li> </ul> <p>As you can see, abstraction depends on the target audience. As the target audience changes, the definition of the target of abstraction can change, and previously relevant/irrelevant information can become irrelevant/relevant as well. Furthermore, both the definition and the relevant information depend on expected interaction of the target audience, i.e., what he/she/it will do with the target of abstraction: for you in a morning rush, the expected interaction is that you will drive the car to your workplace, so the relevant information are how to drive a car; for factory workers, the expected interaction is that they will build cars, so the relevant information are the internal structures of a car.</p> <p>Therefore, it is always important to identify the target audience and understand what he/she/it will do with the target of abstraction, and then decide what information are relevant/irrelevant.</p>"}]}