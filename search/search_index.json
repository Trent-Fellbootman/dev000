{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DEV-000: The Complete Introduction to Development","text":""},{"location":"#what-is-this-course-about-what-can-you-get-out-of-it","title":"What is this course about? What can you get out of it?","text":"<p>This course provides a complete introduction to programming, computers and software development and covers various topics such as:</p> <ul> <li>Programming Languages</li> <li>Terminal &amp; Unix</li> <li>Concurrency</li> <li>Software Design &amp; Project Development</li> <li>Computer Hardware Fundamentals</li> <li>AI Aided Development &amp; AI Application Development</li> </ul> <p>After learning this course, you should be ready to develop large projects with hundreds of thousands of lines of code. And, you will have a good understanding of the fundamental concepts, design choices and tradeoffs that underlies the developer's world. You won't get to know every language, every framework and every piece of syntax; but you will know where to look for answers, what you should checkout and how to solve problems with Google and ChatGPT.</p> <p>The course is NOT complete yet; new sections are being added continuously.</p>"},{"location":"#who-might-find-this-course-helpful","title":"Who might find this course helpful?","text":"<p>This tutorial is for those who:</p> <ul> <li>Are completely new to computers and want to learn programming;</li> <li>Already have some familiarity with programming and wish to learn more and become a \"true developer\".</li> </ul>"},{"location":"#how-to-learn-programming-and-development","title":"How to learn programming and development?","text":"<p>Although this course aims to provide a broad overview of the developer's world, it is by no means a \"look-no-further\" course, and simply browsing through the course contents will not make you a good developer.</p> <p>Development is not only a skill but also a quality, and a mindset as well. To truly master programming and development, coding is indispensable.</p> <p>As such, you should do a lot of coding and practice as you follow along with the course. As for me, I would recommend learning a framework such as Unity or Flutter so that you can create \"exciting things\" (such as games and apps) as you learn to code and find coding more fun.</p> <p>With the advent of GPTs, programming languages (and basically anything) have become much easier to learn. As long as you know what you're looking for, you can always find the answer easily by consulting GPT (most of the time). Therefore, this course does not include a tutorial for any specific language; it only introduces the common concepts that are found in almost all programming languages, and you're encouraged to learn how those concepts maps to specific syntax in different programming languages by Googling or asking GPTs.</p> <p>Personally, I believe that harnessing the power of AI is a very important skill for developers in the 21st century, and I would encourage you to use GPT for anything you can imagine, either for debugging, illustrating programming concepts or recommending frameworks and libraries.</p>"},{"location":"#what-is-the-right-way-to-take-this-course","title":"What is the right way to take this course?","text":"<p>This course is organized into modules. For those completely new to programming and development, it is recommended to learn each module in order, so that you can get a complete and systematic understanding of the developer's world.</p> <p>However, the modules are not strictly dependent on each other, so if you already have some experience, or if you're only interested in certain aspects of development, feel free to find the modules that interest you the most and skip the rest.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Take a look at the course outline and pick a module to start with!</p>"},{"location":"outline/","title":"DEV-000 Course Structure","text":"<p>Note: Some modules are not available yet. The names of available modules are shown as links, while unavailable modules are shown as plain text.</p>"},{"location":"outline/#module-0-the-developers-mindset","title":"Module 0: The Developer's Mindset","text":"<p>This module covers the fundamental concepts that underlies all aspect of the developer's world, such as abstraction and hierarchy.</p> <p>Topics include:</p> <ul> <li>Abstraction</li> <li>Hierarchy</li> <li>Standards</li> </ul>"},{"location":"outline/#module-1-the-abstract-computer","title":"Module 1: The Abstract Computer","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 0: The Developer's Mindset</li> </ul> <p>This module explains how a computer is abstracted to developers. Topics include:</p> <ul> <li>Memory address, stack, heap, etc.</li> <li>How a program gets run: compilation, linking, etc.</li> </ul>"},{"location":"outline/#module-2-programming-languages","title":"Module 2: Programming Languages","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 0: The Developer's Mindset</li> <li>Module 1: The Abstract Computer</li> </ul> <p>This module gives a panoramic introduction to programming languages. This is not a tutorial to a specific language; instead, it explains how programming languages generally work, introduces the syntactical constructs found in almost all mainstream languages and compares the styles and design choices of multiple programming languages.</p> <p>This module does not assume you have any experience with coding, but it is not a programming tutorial. Instead of learning to code by reading this module exclusive, you are expected to consult GPT on how to actually code in specific languages.</p> <p>After learning this module, you should have a good understanding of how modern programming languages work and why they are designed in certain ways. With the help of GPT, you should be able to get started and code in any language.</p> <p>Specific topics covered in this module are listed below.</p>"},{"location":"outline/#programming-fundamentals","title":"Programming Fundamentals","text":"<ul> <li>variables &amp; types</li> <li>control flow statements</li> <li>functions</li> <li>classes</li> <li>modules</li> </ul>"},{"location":"outline/#programming-language-taxonomy","title":"Programming Language Taxonomy","text":"<ul> <li>Compiled Languages v.s. Interpreted Languages + virtual-machine-based</li> <li>Static typing v.s. Dynamic typing</li> <li>Garbage collection v.s. manual resource management</li> <li>High-level v.s. low-level</li> </ul>"},{"location":"outline/#common-concepts-in-programming-languages","title":"Common Concepts in Programming Languages","text":"<ul> <li>Abstraction</li> <li>Interfaces &amp; ABCs &amp; Polymorphism</li> <li>Meta-programming</li> <li>find-replace-based macros</li> <li>generics</li> <li>Ownership &amp; lifetimes</li> <li>Error Handling</li> <li>try-catch</li> <li>Result</li> </ul>"},{"location":"outline/#other-abnormal-languages","title":"Other \"Abnormal\" Languages","text":"<ul> <li>LISP</li> </ul>"},{"location":"outline/#module-3-coding-properly","title":"Module 3: Coding Properly","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages</li> </ul> <p>This module explains the \"good practices\" and paradigms in programming, and more importantly, the logic behind them.</p> <p>After learning this module, you should get a good idea of how to design and code up large projects with hundreds of thousands of lines of code.</p>"},{"location":"outline/#common-coding-practices","title":"Common Coding Practices","text":"<ul> <li>Code Styling</li> <li>CODE_OF_CONDUCT</li> <li>Identifiers Naming Conventions</li> <li>Comments &amp; docstrings</li> <li>Testing (just mention some concepts)</li> </ul>"},{"location":"outline/#programming-principles","title":"Programming Principles","text":"<ul> <li>Syntax &amp; Semantics: What it can be v.s. What it should be (and usually be)</li> <li>Don't repeat yourself</li> <li>The rule of elegance</li> <li>Hierarchy</li> <li>Coupling &amp; Cohesion</li> <li>Depend on interfaces, not implementations</li> <li>Write comments</li> <li>When the program is short, forget about all principles</li> </ul>"},{"location":"outline/#programming-paradigms","title":"Programming Paradigms","text":"<ul> <li>Object Oriented Programming</li> <li>Functional Programming</li> </ul>"},{"location":"outline/#designing-software-systems","title":"Designing Software Systems","text":"<ul> <li>Modules &amp; APIs &amp; Interfaces</li> <li>Coupling &amp; Cohesion</li> <li>Other Considerations</li> <li>Abstract your dependencies</li> </ul>"},{"location":"outline/#module-4-terminal-superuser-basics","title":"Module 4: Terminal &amp; Superuser Basics","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages (recommended)</li> </ul> <p>This module introduces terminal, operating system basics and other \"superuser stuff\".</p> <p>This module should take you from a \"regular user\" who interacts with a computer by dragging-dropping and pushing buttons to a \"superuser\" who feels comfortable using terminals and doing multi-booting.</p> <p>Specific topics are listed below.</p>"},{"location":"outline/#terminal-shell-scripting","title":"Terminal &amp; Shell Scripting","text":"<ul> <li>What is a terminal? What is a shell? What is a shell script?</li> <li>Taxonomy of shell scripting languages: text-based (bash) v.s. data-oriented (powershell &amp; nushell)</li> <li>Key differences between scripting languages and programming languages</li> <li>Shell scripting basics</li> <li>Basic commands<ul> <li>cd, pwd, pushd, popd, find, ...</li> </ul> </li> <li>variables &amp; control flows, etc.</li> <li>commands</li> <li>pipes &amp; redirection</li> <li>environment variables</li> <li>Miscellaneous<ul> <li>&amp;&amp;, ;, $!, ...</li> </ul> </li> <li>Terminal Tricks &amp; Common Practices</li> <li>Auto-completion, history, etc.</li> <li>Shell config files</li> <li>Prompt-customization &amp; theming</li> <li>Shell plugins</li> <li>Common Tools &amp; Commands<ul> <li>grep, cut, awk, tmux, ssh, etc.</li> </ul> </li> </ul>"},{"location":"outline/#package-management","title":"Package Management","text":"<ul> <li>Software dependencies</li> <li>Software packages</li> <li>Package managers</li> </ul>"},{"location":"outline/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Config files</li> <li>vim &amp; emacs</li> <li>Virtualization &amp; docker</li> <li>Booting</li> <li>Hard drive partitions &amp; (g)parted</li> <li>Bootloaders &amp; GRUB</li> <li>BIOS &amp; UEFI</li> <li>Dual (Multi) Booting</li> <li>Linux potpourri</li> <li>kernel modules</li> </ul>"},{"location":"outline/#module-5-software-development","title":"Module 5: Software Development","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages</li> <li>Module 3: Coding Properly</li> </ul> <p>This module explains the common concepts and tools involved with software development.</p> <p>After learning this module, you should feel comfortable starting a large project, coding it up with a team, and publishing it to the public.</p> <p>Specific topics are listed below.</p>"},{"location":"outline/#common-concepts-in-software-systems","title":"Common Concepts in Software Systems","text":"<ul> <li>Versioning &amp; Dependencies</li> <li>Semantic Versioning</li> <li>Interfaces &amp; APIs &amp; Libraries</li> <li>Remote Procedure Call (RPC)</li> <li>Serialization &amp; Deserialization</li> <li>Inter-process communication (IPC)</li> <li>Frameworks</li> <li>What is a framework? Why framework?</li> <li>Framework v.s. Library</li> <li>Examples: Flutter (UI), PyTorch (deep learning) &amp; Unity (game development)</li> <li>Specification &amp; Standards (Use examples to illustrate the concept)</li> <li>Why standards?</li> <li>Examples<ul> <li>CPU Instruction Set Architectures (ISAs)</li> <li>GPU specifications (OpenGL &amp; Vulkan)</li> <li>Data Representation Standards (JSON, TOML, YAML, XML, HTML)</li> </ul> </li> </ul>"},{"location":"outline/#testing","title":"Testing","text":"<ul> <li>Unit testing</li> </ul>"},{"location":"outline/#documentation","title":"Documentation","text":"<ul> <li>Docstrings</li> <li>API Docs</li> <li>Tutorials</li> <li>Doctests</li> <li>Common documentation frameworks &amp; languages</li> <li>Sphinx &amp; mkdocs (just mention)</li> <li>Markdown &amp; RST</li> </ul>"},{"location":"outline/#building-deployment-tentative","title":"Building &amp; Deployment (tentative)","text":"<ul> <li>Build systems</li> </ul>"},{"location":"outline/#version-control","title":"Version Control","text":"<ul> <li>Version control &amp; git</li> </ul>"},{"location":"outline/#standardization-collaboration","title":"Standardization &amp; Collaboration","text":"<ul> <li>The need for standardization across contributors</li> <li>CODE_OF_CONDUCT</li> </ul>"},{"location":"outline/#cicd","title":"CI/CD","text":""},{"location":"outline/#miscellaneous_1","title":"Miscellaneous","text":"<ul> <li>PRs &amp; Issues</li> <li>README, CONTRIBUTE, LICENSE</li> <li>TODOs &amp; FIXMEs</li> </ul>"},{"location":"outline/#module-6-concurrent-programming","title":"Module 6: Concurrent Programming","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages</li> <li>Module 3: Coding Properly (recommended)</li> </ul> <p>This is a relatively stand-alone module that explains the concepts involved with concurrent programming.</p> <p>Topics are listed below.</p>"},{"location":"outline/#introduction-to-concurrency","title":"Introduction to Concurrency","text":""},{"location":"outline/#concurrency-model","title":"Concurrency Model","text":"<ul> <li>Concurrency v.s. parallelism</li> </ul>"},{"location":"outline/#problems-with-concurrency","title":"Problems with Concurrency","text":"<ul> <li>Data races</li> </ul>"},{"location":"outline/#low-level-concurrent-programming","title":"Low-level concurrent programming","text":""},{"location":"outline/#synchronization-primitives","title":"Synchronization primitives","text":"<ul> <li>Locks (Mutexes)</li> <li>Semaphores</li> <li>Read-Write Locks</li> </ul>"},{"location":"outline/#concurrent-programming-paradigms","title":"Concurrent Programming Paradigms","text":""},{"location":"outline/#channels","title":"Channels","text":""},{"location":"outline/#producer-consumer","title":"Producer &amp; Consumer","text":""},{"location":"outline/#asynchronous-programming","title":"Asynchronous Programming","text":"<ul> <li>Futures &amp; poll</li> <li>async &amp; await</li> </ul>"},{"location":"outline/#module-7-computer-architecture-fundamentals","title":"Module 7: Computer Architecture Fundamentals","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 1: The Abstract Computer</li> <li>Module 2: Programming Languages (strongly recommended)</li> </ul> <p>This module introduces the very basics of how computers work in hardware.</p> <p>After learning this module, you should have a deeper understanding of computers and be able to code programs that utilize the hardware in an optimized way.</p> <p>Topics are listed below.</p>"},{"location":"outline/#cpus","title":"CPUs","text":"<ul> <li>Pipelines</li> <li>Memory Hierarchy</li> <li>Branch Prediction &amp; Speculative Execution</li> <li>Out of order processing</li> <li>Vector instructions &amp; SIMD</li> </ul>"},{"location":"outline/#gpus-accelerators","title":"GPUs &amp; Accelerators","text":""},{"location":"outline/#module-8-miscellaneous-topics-in-the-developers-world","title":"Module 8: Miscellaneous Topics in the Developer's World","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages (strongly recommended)</li> <li>Module 3: Coding Properly (recommended)</li> </ul> <p>This section discusses the various fields and common tools in the developer's world.</p> <p>Topics are listed below.</p>"},{"location":"outline/#ui-app-development","title":"UI &amp; App Development","text":"<ul> <li>Declarative UI v.s. Imperative U</li> </ul>"},{"location":"outline/#game-development","title":"Game Development","text":"<ul> <li>Entity Component System (ECS)</li> </ul>"},{"location":"outline/#gpu-programming","title":"GPU Programming","text":"<ul> <li>High-level: OpenGL</li> <li>Low-level: Vulkan</li> </ul>"},{"location":"outline/#miscellaneous_2","title":"Miscellaneous","text":"<ul> <li>Stackoverflow</li> <li>GitHub</li> <li>IDEs</li> <li>LSPs</li> <li>Hugging Face</li> </ul>"},{"location":"outline/#module-9-ai-aided-development-ai-software-development","title":"Module 9: AI Aided Development &amp; AI Software Development","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages</li> <li>Module 3: Coding Properly (Recommended)</li> </ul> <p>This module discusses how to use AI to develop better, and how to develop applications that take advantage of AI.</p> <p>Topics are listed below.</p>"},{"location":"outline/#artificial-intelligence-basics","title":"Artificial Intelligence Basics","text":"<ul> <li>Deep learning fundamentals</li> <li>Abstracting deep neural networks &amp; AI services for developers</li> </ul>"},{"location":"outline/#ai-aided-development","title":"AI Aided Development","text":"<ul> <li>Code-completion</li> <li>AI Code Generation (logic code, unit tests, documentation, etc.)</li> <li>Auto internationalization</li> <li>AI as an augmented Google</li> </ul>"},{"location":"outline/#ai-software-development","title":"AI Software Development","text":""},{"location":"outline/#a-change-of-mindset-how-is-this-different-from-traditional-software-development","title":"A Change of Mindset: How is this different from \"traditional software development\"?","text":"<ul> <li>Determinism -&gt; Non-deterministic behavior</li> <li>Structured Data -&gt; Natural Language</li> <li>AI involved control flows</li> <li>Short latency -&gt; long-running operations</li> <li>Error Handling &amp; How to ensure robustness when there is AI</li> </ul>"},{"location":"outline/#paradigms-common-practices-at-present","title":"Paradigms &amp; Common Practices at Present","text":"<ul> <li>AI Agents</li> <li>Retrieval Augmented Generation (RAG) &amp; Vector Databases</li> <li>Prompt Engineering &amp; Prompt templates</li> </ul>"},{"location":"abstract-computer/","title":"Module 1: The Abstract Computer","text":"<p>This module assumes that you know the fundamental ideas in the developer's world, specifically, abstraction, hierarchy and standards. If you don't, please take a look at Module 0: The Developer's Mindset before learning this module.</p> <p>This module introduces the various abstractions of computers applicable to developers, that is, what computers look like to developers. Understanding this is essential to understanding why programming languages are designed in the way they are and the logic behind their design choices, and it also helps you to understand what you can do or cannot do in coding, as well as the \"why\".</p> <p>In later sections, you will find that a lot of concepts introduced in this section (such as memory address space, stack and heap) apply to virtually all programming languages.</p> <p>Let's dive right in!</p>"},{"location":"abstract-computer/why-abstraction/","title":"The Abstract Computer: Why do we need it?","text":""},{"location":"developer-mindset/","title":"Module 0: The Developer's Mindset","text":"<p>Before diving into coding, it is beneficial to first understand the fundamental ideas behind the developer's world and develop a \"developer's mindset\", so that you understand not only how to code, but also why programming languages are designed in the way they are, and why you should code in certain ways instead of others. This is what this module is all about.</p> <p>This module may seem to have nothing to do with programming, but the ideas are universal and broadly applicable to almost everything in the developer's world.</p> <p>This module does not assume you have any experience with programming or have learned any other module in this course.</p>"},{"location":"developer-mindset/abstraction/","title":"Abstraction: The Developer's Way of Thinking","text":"<p>The single most important idea that every developer must have is abstraction, a fundamental concept underlying all software systems, hardware architectures, and essentially, all complicated things.</p> <p>Abstraction helps to manage the complexity of real world systems, to break down complex systems into simpler components and to allow both the creator and non-creators something to quickly understand \"what this thing is\". Abstraction is found in almost every aspect in the modern world, from software applications to hardware and even \"non-technical\" industries such as animated films. However, it is especially important to developers as they deal with and use this concept every day. Essentially, abstraction should be the second instinct of all developers.</p>"},{"location":"developer-mindset/abstraction/#what-is-abstraction","title":"What is \"abstraction\"?","text":"<p>Generally speaking, \"to abstract\" roughly means \"to define what something is to someone, disregarding all irrelevant information\", and that definition (\"what something is\") is called an abstraction.</p> <p>Notice that some people may define \"abstraction\" differently, such as \"the abstract nature that is common to multiple entities\". Here, I'm splitting that definition into two parts: the \"abstract nature\" part is defined as abstraction; the \"common to multiple entities\" part is defined as \"standards\", which is a concept introduced in a later section.</p> <p>According to the definition above, there are a few important questions to ask when abstracting something:</p> <ol> <li>What is the \"thing\" to be abstracted?</li> <li>Who is that \"someone\"? How will he/she/it interact with the \"thing\"?</li> <li>What is this \"thing\", in that \"someone\"'s view?</li> <li>What information are relevant? What information are not? I.e., What does that \"someone\" need to know about?</li> </ol> <p>Notice that the answer to these questions are dependent to the \"target audience\" of the abstraction, i.e., the person (or the system) that will use the abstraction and interact with the \"thing\". If your audience changes, the \"thing\" might look different, relevant information might become irrelevant, and vice versa.</p> <p>Abstraction is not meant for other people only; sometimes (actually most of the time), the target audience will be yourself who is designing and implementing the thing to be abstracted.</p> <p>Although I gave a definition above, abstraction itself is an \"abstract\" idea which is very hard to define clearly, and there is no broadly-accepted definition. So, I will use an example to illustrate what abstraction really means.</p>"},{"location":"developer-mindset/abstraction/#an-example-of-abstraction","title":"An Example of Abstraction","text":"<p>When you're in a morning rush and you see a car, what first comes to your mind? Is it \"I can drive this thing around\", or chassis, engine, tires and fuel tanks?</p> <p>I believe most people's view would be the former. Of course, the latter view is also important, but it is irrelevant to you at the moment: you're in a rush, so all that matters to you is that you can drive a car to get to your workplace fast.</p> <p>Believe it or not, you have already created an abstraction in the example above. Let's break it down a little:</p> <ul> <li>Target of abstraction: The car.</li> <li>Target audience: You.</li> <li>What is this thing (\"abstraction\"): Something you can use to drive around and get to anywhere fast.</li> <li>Relevant information: You can drive this thing around. It's fast.</li> <li>Irrelevant information: It's made up of an engine, a fuel tank, a chassis, etc. It's 4.6 meters long and 1.6 meters tall, with a peak power output of 140 hp. Stuff like that.</li> </ul> <p>The explanation above should be easy to understand: the target audience is you, and the only thing you need to know is that you can drive a car around, so that's the abstraction.</p> <p>For workers at a car factory, however, the view would be different. The workers build cars; they do not need to know how to drive the car, but they do need to know the inner workings of a car so that they can build it. This time, we have:</p> <ul> <li>Target of abstraction: The car.</li> <li>Target audience: Factory workers.</li> <li>What is this thing (\"abstraction\"): Something made of an engine, a fuel tank, a chassis and a bunch of other stuff.</li> <li>Relevant information: Internal structures of a car.</li> <li>Irrelevant information: How to drive a car.</li> </ul> <p>As you can see, abstraction depends on the target audience. As the target audience changes, the definition of the target of abstraction can change, and previously relevant/irrelevant information can become irrelevant/relevant as well.</p> <p>Abstraction also depends on the role of the target audience. When you're driving a car, the abstraction of a car is \"something you can drive\"; when you're repairing a car, the abstraction starts including engines, tires, etc., because such details are now relevant to you.</p> <p>Therefore, it is always important to identify the target audience and understand what it will do with the target of abstraction, and then decide what information are relevant/irrelevant and abstract the \"thing\" to the audience.</p>"},{"location":"developer-mindset/abstraction/#what-does-abstraction-look-like-in-the-developers-world","title":"What does abstraction look like in the developer's world?","text":"<p>Although the car example illustrates the concept of abstraction, it seems to have nothing to do with developer stuff. Now, let's see what abstraction look like in real world software systems and code.</p> <p>Here's a source code fragment from KonnyakuGPT, an AI-powered anime subtitle generator (there is no need to understand the code):</p> <pre><code>def simple_split_subtitles(subtitles: Sequence[srt.Subtitle], max_duration: datetime.timedelta) -&gt; List[srt.Subtitle]:\n    \"\"\"Splits subtitles that are too long.\n\n    The splitting scheme is simple; sentences are LIKELY to be broken into pieces.\n\n    Args:\n        subtitles (Sequence[srt.Subtitle]): Original subtitles.\n        max_duration (float, optional): The maximum duration of each output subtitle, in seconds. Defaults to 10.\n    \"\"\"\n\n    new_subtitles = []\n    for subtitle in subtitles:\n        remaining_text = subtitle.content\n        current_start = subtitle.start\n        splitted_subtitles = []\n\n        while len(remaining_text) &gt; 0:\n            expected_text_length = math.floor(max_duration / (subtitle.end - current_start) * len(remaining_text))\n            actual_text_length = min(expected_text_length, len(remaining_text))\n            item_text = remaining_text[:actual_text_length]\n            item_duration = len(item_text) / len(remaining_text) * (subtitle.end - current_start)\n\n            splitted_subtitles.append(srt.Subtitle(\n                index=len(new_subtitles) + len(splitted_subtitles),\n                start=current_start,\n                end=current_start + item_duration,\n                content=item_text\n            ))\n\n            remaining_text = remaining_text[actual_text_length:]\n            current_start += item_duration\n\n        new_subtitles += splitted_subtitles\n\n    return new_subtitles\n</code></pre> <p>There is no need to understand what the code does and how it does its job for now. Basically, the code segment makes up a function (think of it as a tool you can use to do something) which can split up long subtitles into shorter ones.</p> <p>You may have noticed that there is some human-readable text at the beginning, namely the following:</p> <pre><code>\"\"\"Splits subtitles that are too long.\n\nThe splitting scheme is simple; sentences are LIKELY to be broken into pieces.\n\nArgs:\n    subtitles (Sequence[srt.Subtitle]): Original subtitles.\n    max_duration (float, optional): The maximum duration of each output subtitle, in seconds. Defaults to 10.\n\"\"\"\n</code></pre> <p>Such text is called a \"docstring\", which, as its name suggests, provides documentation for the function. Such a docstring serves as an abstraction to the user of the function, as it includes and only includes what the user needs to know: what the function does and how to use it. The rest of the function, i.e., everything after the docstring, are all irrelevant to the user even though they are the logic code that allow the function to work. The user only needs to know how to use the function; it does not care about how the function works internally.</p> <p>Abstraction is very important in this scenario, because it allows the user of the function to quickly understand only the things that it needs to understand. Without the docstring, the only way to see what the function does is to read and understand the code. While this is possible, it is much more time consuming than reading the docstring, and a bigger problem is, if the logic code changes, users would need to change the way they use the function, which will result in a lot of code modifications. With abstraction however, no matter how the logic code changes, as long as it maintains the interface (i.e., what the function does and how to use it) defined in the abstraction, the users don't need to change how they use the function at all.</p> <p>Abstractions are important not only to users of software systems, but to those who develop the system as well. When there are a lot of code involved in a software (e.g., KonnyakuGPT has roughly ~2,000 lines of Python code), it becomes hard to remember what each piece of code does. Without abstractions like docstrings, even you yourself will find it hard to understand the code you written previously; abstractions make it much easier to understand, organize and maintain the software you work on.</p> <p>Congratulations! You have understood abstraction, which is a concept fundamental to all programming languages and software development processes. Next, we will take a look at hierarchy, which is a way to manage complexity and an idea used in every aspect of the developer's world.</p>"},{"location":"developer-mindset/conclusion/","title":"Conclusion","text":"<p>In this section, we touched upon the most fundamental ideas which form the foundation of the \"developer's mindset\". Although these ideas seem simple, they underlie virtually everything in the developer's world, and for good developers, these ideas are typically second instincts.</p> <p>The key takeaways are:</p> <ul> <li>To abstract means to give a definition of something to someone, disregarding all information irrelevant to that \"someone\"; that \"definition\" is called the abstraction of that \"something\".</li> <li>A hierarchy is a tree of abstractions formed by grouping things together according to some rule, where the child abstractions relate to their parent abstractions in some way.</li> <li>A standard is an abstraction which is shared across multiple entities, and provides a unified way that allows different entities to interact with each other properly.</li> </ul> <p>Even though what you learned in this section may seem to have nothing to do with programming, it provides a solid foundation that allows you to understand the logic behind different design choices and tradeoffs in the developer's world. That is, it allows you to understand not only \"how\" to do things, but also the \"why\".</p> <p>You're on the right track, and you have made a good first step on the journey of becoming a good developer!</p> <p>In the next section, we will take a look at how computers are abstracted to software applications and developers; this forms the basis of all programming languages and all software development processes.</p>"},{"location":"developer-mindset/hierarchy/","title":"Hierarchy: A Way to Manage Complexity","text":"<p>The second most important idea following abstraction is the idea of hierarchy. Hierarchy is a way to manage complexity, and is found in almost every software application.</p>"},{"location":"developer-mindset/hierarchy/#what-does-hierarchy-mean","title":"What does \"hierarchy\" mean?","text":"<p>Broadly speaking, the idea of hierarchy is about grouping things together and forming a tree of abstractions; that \"tree of abstractions\" is called a \"hierarchy\".</p> <p>That's a very abstract definition, so let's look at an example.</p> <p>Suppose you are a college students and you have the following files for course assignments, PPT slides, etc.:</p> <pre><code>introduction-to-ai.pdf\ncalculus-assignment-1.pdf\nprogramming-assignment-2.py\nliterature-textbook.epub\nintroduction-to-ai-lecture-2.pdf\ncalculus-assignment-2.pdf\nprogramming-assignment-3.py\nliterature-review-article.epub\nintroduction-to-ai-project-outline.docx\ncalculus-final-exam-review.pdf\nprogramming-code-snippets.txt\nliterature-essay-draft.docx\nintroduction-to-ai-research-paper.pdf\ncalculus-quiz-answers.docx\nprogramming-tutorial-slides.pptx\nliterature-poetry-analysis.pdf\n</code></pre> <p>Man, that's a lot of files. And it looks messy, doesn't it?</p> <p>A natural idea would be to group them into folders, for example:</p> <pre><code>course-files/\n  AI/\n    introduction-to-ai.pdf\n    introduction-to-ai-lecture-2.pdf\n    introduction-to-ai-project-outline.docx\n    introduction-to-ai-research-paper.pdf\n  Calculus/\n    calculus-assignment-1.pdf\n    calculus-assignment-2.pdf\n    calculus-final-exam-review.pdf\n    calculus-quiz-answers.docx\n  Programming/\n    programming-assignment-2.py\n    programming-assignment-3.py\n    programming-code-snippets.txt\n    programming-tutorial-slides.pptx\n  Literature/\n    literature-textbook.epub\n    literature-review-article.epub\n    literature-essay-draft.docx\n    literature-poetry-analysis.pdf\n</code></pre> <p>That looks much better, right? Files for the same subject are grouped together, and this way, you can find what you need much more easily.</p> <p>That is the idea of hierarchy. Recall the definition of hierarchy: the idea of hierarchy is about grouping things together and forming a tree of abstractions. Here, we group the files together according to the subject they belong to. You might ask: \"where's the 'tree of abstractions'?\" Well, the above directory structure can also be represented using the following graph:</p> <pre><code>mindmap\n  root((course-files))\n    AI\n      introduction-to-ai.pdf\n      introduction-to-ai-lecture-2.pdf\n      introduction-to-ai-project-outline.docx\n      introduction-to-ai-research-paper.pdf\n\n    Calculus\n      calculus-assignment-1.pdf\n      calculus-assignment-2.pdf\n      calculus-final-exam-review.pdf\n      calculus-quiz-answers.docx\n\n    Programming\n      programming-assignment-2.py\n      programming-assignment-3.py\n      programming-code-snippets.txt\n      programming-tutorial-slides.pptx\n\n    Literature\n      literature-textbook.epub\n      literature-review-article.epub\n      literature-essay-draft.docx\n      literature-poetry-analysis.pdf</code></pre> <p>This looks just like the branches of a tree. Each node in the tree represents an abstraction, and the abstraction of the child relates to that of its parent. For example, the abstraction of the \"course-files\" folder might be \"all the files for the college courses\"; its children are \"AI\", \"Calculus\", \"Programming\", and \"Literature\", and each of these folders abstracts away \"all the files for a certain course\", which is a part of \"all the files for the courses\".</p> <p>Now that you have a rough understanding of hierarchy, let's look at some common types of hierarchies to understand the idea better.</p>"},{"location":"developer-mindset/hierarchy/#common-types-of-hierarchy","title":"Common Types of Hierarchy","text":""},{"location":"developer-mindset/hierarchy/#composition","title":"Composition","text":"<p>Composition is possibly the most common type of hierarchy. A composition hierarchy is a hierarchy where, in the tree of abstraction, the parent contains the children.</p> <p>The previous course files example is a composition hierarchy. In this example, \"course-files\" folder is the parent of \"AI\", \"Calculus\", \"Programming\", and \"Literature\" folders; the folder for each course is the parent of the files of that course. \"course-files\" contains the course folders; each course folder contains its files. That is, the parent contains the children.</p> <p>Another example is a car. On the highest level, a car consists of a car body, engine, chassis, and the wheels. Then, the car body contains doors and windows, the engine contains gears and cylinders, and so on.</p> <pre><code>graph TD\n\nCar\n\nCar --&gt; Car-Body\nCar --&gt; chassis\nCar --&gt; Wheels\nCar --&gt; Engine\n\nCar-Body --&gt; Doors\nCar-Body --&gt; Windows\n\nEngine --&gt; Gears\nEngine --&gt; Cylinders</code></pre>"},{"location":"developer-mindset/hierarchy/#general-to-specific-hierarchy","title":"General-to-Specific Hierarchy","text":"<p>Another common type of hierarchy is the general-to-specific hierarchy. In a hierarchy of this type, the parent generalizes its children, and its abstraction is the intersection of the natures of the children.</p> <p>For example, consider the following hierarchy:</p> <pre><code>graph TD\n\nCreatures\n\nCreatures --&gt; Plants\n\nPlants --&gt; Trees\n\nPlants --&gt; Grass\n\nCreatures --&gt; Animals\n\nAnimals --&gt; Insects\n\nAnimals --&gt; Mammals\n\nMammals --&gt; Humans</code></pre> <p>In this hierarchy, \"Animals\" is a type of \"Creatures\"; \"Mammals\" is a type of \"Animals\"; and \"Humans\" is a type of \"Mammals\", etc. That is, each child is a type of the parent, plus some characteristics specific to itself; the characteristics of the parent is common to all of its children.</p>"},{"location":"developer-mindset/hierarchy/#why-is-hierarchy-important","title":"Why is hierarchy important?","text":"<p>Hierarchy is important, because it allows a system to be abstracted differently at different levels, which makes it easier to design, understand and maintain.</p> <p>Suppose we want to design a car. Without a hierarchy, we would need to design every single part together, from every bolt on the steering wheel to every gear in the engine. As there can be tens of thousands of parts in the car, it would be very hard to keep track of all of them and make sure they all work together.</p> <p>When the car is malfunctioning, we would need to check every part to find the faulty one and replace it; if we want to explain how the car works, we would need to explain what each part does, and the fact the all the parts cooperate to make up a functional car would probably look like magic.</p> <p>With the idea of hierarchy in mind, we would split up the car into more manageable pieces. For example, we can have one team of engineers to work on the engine, another team to work on the chassis, etc. And the team that works on the engine may further split up the engine into smaller pieces to make sure they all work together. The team that works on the engine does not need to know how the chassis works (generally); and vice versa.</p> <p>When the car is malfunctioning, we would first check each high-level component to see if it works correctly, identify the faulty component, check all of its sub-components, until finally reaching the broken part; although this is a lot of work as well, it is much easier than checking through every bolt and gear. If we want to explain how the car works, we would first explain the function of each top-level components, and then explain how the sub-components work together and make up a functional high-level component. Obviously, it is much easier to explain the car this way than first describe what each screw does, and \"suddenly, the parts just magically become a working car\".</p> <p>In software development, \"replacing the faulty part\" roughly maps to fixing the faulty piece of code; \"explaining how the car works\" roughly maps to understanding how the software is made up, so that you know how to write code for it.</p> <p>As you can see, by decomposing complex systems and grouping things together, the idea of hierarchy allows people to manage complexity, and to design and understand complex systems effectively.</p> <p>Congratulations! You have now learned the idea of hierarchy. Next, we are going to talk about the last concept in this module: standards.</p>"},{"location":"developer-mindset/standards/","title":"Standards: Facilitating Interactions Between Entities","text":"<p>In the 18th century, guns were made by skilled gunsmiths; every gun made in this way was a unique object. This makes guns extremely expensive and hard to repair if broken, as the only way to fix it is to send it back to the gunsmith and have him/her repair his/her creation by hand.</p> <p>So, in the mid-18th century, a French gunsmith named Honor\u00e9 LeBlanc suggested that gun parts be made standardized. Standardized gun parts work with each other regardless of their creators; in this way, if a gun is broken, it can be easily fixed by replacing the faulty part with a new one.</p> <p></p> <p>Although Honor\u00e9 LeBlanc died a long time ago, his idea of standardization lives on, and became one of the foundations of modern software development.</p> <p>In this section, we will discuss the idea of standardization and its significance.</p>"},{"location":"developer-mindset/standards/#what-is-a-standard","title":"What is a standard?","text":"<p>Roughly speaking, a standard is an abstraction shared across multiple entities. Such a definition contains two parts:</p> <ul> <li>What is the abstraction?</li> <li>To what entities is the abstraction applicable?</li> </ul> <p>Standards are important, because:</p> <ul> <li>They provide a standardized way for multiple entities to interact with each other, and as long as the interaction adheres to the standard, it is \"guaranteed to work properly\"; and</li> <li>When designing something, depending on \"abstract standards\" is better than depending on \"concrete things\", as the former works with anything that adheres to the standard, while the latter works with only with a specific thing.</li> </ul> <p>Let's look at an example to understand the idea better.</p>"},{"location":"developer-mindset/standards/#an-example-of-standards","title":"An Example of Standards","text":"<p>One notable example of standards are Instruction Set Architectures (ISAs). An ISA is basically an abstraction of a computer, which defines what operations it must support, such as math operations like addition and subtraction.</p> <p>The previous definition of a standard applies to an ISA:</p> <ul> <li>What is the abstraction? The abstraction is the set of operations that must be supported, defined by the ISA.</li> <li>To what entities is the abstraction applicable? The standard (abstraction) is applicable to all computers that support the operations defined by the ISA.</li> </ul> <p>Why is this important? Well, have you wondered why software applications can run on different computers, made by different vendors and equipped with different CPUs? Each computer is different, and older computers and new ones likely don't have the same hardware, so why does the same application work on both of them?</p> <p>The answer is, a software application doesn't depend on a specific hardware; instead, it depends on a certain ISA. I.e., it only uses the operations defined by the ISA. As the same time, different computers can implement (i.e., support the instructions defined by) the same ISA. In this way, as long as a computer supports a certain ISA, it can run any software that targets it: the software only uses the operations defined by the ISA; the computer supports that ISA so that all ISA operations are guaranteed to work; therefore, the software is guaranteed to work properly.</p> <pre><code>%%{init: { \"flowchart\": { \"curve\": \"linear\" } } }%%\ngraph TD\n\nSoftware-1 --&gt; ISA\nSoftware-2 --&gt; ISA\nSoftware-3 --&gt; ISA\n\nISA --&gt; Computer-1\nISA --&gt; Computer-2\nISA --&gt; Computer-3</code></pre> <p>As you can see, an ISA serves as an \"agreement\" between software applications and computer hardwares; as long as the software and the hardware interact with each other in a way that adheres to the ISA standard (i.e., the software uses only the operations defined by the ISA, and the hardware supports the ISA), the software is guaranteed to work properly. Adhering the ISA standard brings tremendous benefits to both software and hardware developers: without an ISA, software developers would have to program the same software for every computer, whereas the ISA reduces that to programming the software only for a few ISAs; such benefits applies to hardware manufacturers as well.</p> <p>Congratulations! You have learned the idea of standards, which is the an important concept that underlies virtually all software applications.</p>"}]}