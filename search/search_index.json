{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DEV-000: The Complete Introduction to Development","text":""},{"location":"#what-is-this-course-about-what-can-you-get-out-of-it","title":"What is this course about? What can you get out of it?","text":"<p>This course provides a complete introduction to programming, computers and software development and covers various topics such as:</p> <ul> <li>Programming Languages</li> <li>Terminal &amp; Unix</li> <li>Concurrency</li> <li>Software Design &amp; Project Development</li> <li>Computer Hardware Fundamentals</li> <li>AI Aided Development &amp; AI Application Development</li> </ul> <p>After learning this course, you should be ready to develop large projects with hundreds of thousands of lines of code. And, you will have a good understanding of the fundamental concepts, design choices and tradeoffs that underlies the developer's world. You won't get to know every language, every framework and every piece of syntax; but you will know where to look for answers, what you should checkout and how to solve problems with Google and ChatGPT.</p> <p>The course is NOT complete yet; new sections are being added continuously.</p>"},{"location":"#who-might-find-this-course-helpful","title":"Who might find this course helpful?","text":"<p>This tutorial is for those who:</p> <ul> <li>Are completely new to computers and want to learn programming;</li> <li>Already have some familiarity with programming and wish to learn more and become a \"true developer\".</li> </ul>"},{"location":"#how-to-learn-programming-and-development","title":"How to learn programming and development?","text":"<p>Although this course aims to provide a broad overview of the developer's world, it is by no means a \"look-no-further\" course, and simply browsing through the course contents will not make you a good developer.</p> <p>Development is not only a skill but also a quality, and a mindset as well. To truly master programming and development, coding is indispensable.</p> <p>As such, you should do a lot of coding and practice as you follow along with the course. As for me, I would recommend learning a framework such as Unity or Flutter so that you can create \"exciting things\" (such as games and apps) as you learn to code and find coding more fun.</p> <p>With the advent of GPTs, programming languages (and basically anything) have become much easier to learn. As long as you know what you're looking for, you can always find the answer easily by consulting GPT (most of the time). Therefore, this course does not include a tutorial for any specific language; it only introduces the common concepts that are found in almost all programming languages, and you're encouraged to learn how those concepts maps to specific syntax in different programming languages by Googling or asking GPTs.</p> <p>Personally, I believe that harnessing the power of AI is a very important skill for developers in the 21st century, and I would encourage you to use GPT for anything you can imagine, either for debugging, illustrating programming concepts or recommending frameworks and libraries.</p>"},{"location":"#what-is-the-right-way-to-take-this-course","title":"What is the right way to take this course?","text":"<p>This course is organized into modules. For those completely new to programming and development, it is recommended to learn each module in order, so that you can get a complete and systematic understanding of the developer's world.</p> <p>However, the modules are not strictly dependent on each other, so if you already have some experience, or if you're only interested in certain aspects of development, feel free to find the modules that interest you the most and skip the rest.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Take a look at the course outline and pick a module to start with!</p>"},{"location":"outline/","title":"DEV-000 Course Structure","text":"<p>Note: Some modules are not available yet. The names of available modules are shown as links, while unavailable modules are shown as plain text.</p>"},{"location":"outline/#module-0-the-developers-mindset","title":"Module 0: The Developer's Mindset","text":"<p>This module covers the fundamental concepts that underlies all aspect of the developer's world, such as abstraction and hierarchy.</p> <p>Topics include:</p> <ul> <li>Abstraction</li> <li>Hierarchy</li> <li>Standards</li> </ul>"},{"location":"outline/#module-1-the-abstract-computer","title":"Module 1: The Abstract Computer","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 0: The Developer's Mindset</li> </ul> <p>This module explains how a computer is abstracted to developers. Topics include:</p> <ul> <li>Instruction Set Architectures (ISAs).</li> <li>Memory use cases, stack and heap.</li> </ul>"},{"location":"outline/#module-2-programming-languages","title":"Module 2: Programming Languages","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 0: The Developer's Mindset</li> <li>Module 1: The Abstract Computer</li> </ul> <p>This module gives a panoramic introduction to programming languages. This is not a tutorial to a specific language; instead, it explains how programming languages generally work, introduces the syntactical constructs found in almost all mainstream languages and compares the styles and design choices of multiple programming languages.</p> <p>This module does not assume you have any experience with coding, but it is not a programming tutorial. Instead of learning to code by reading this module exclusive, you are expected to consult GPT on how to actually code in specific languages.</p> <p>After learning this module, you should have a good understanding of how modern programming languages work and why they are designed in certain ways. With the help of GPT, you should be able to get started and code in any language.</p> <p>Specific topics covered in this module are listed below.</p>"},{"location":"outline/#programming-fundamentals","title":"Programming Fundamentals","text":"<ul> <li>variables &amp; types</li> <li>control flow statements</li> <li>functions</li> <li>classes</li> <li>modules</li> </ul>"},{"location":"outline/#programming-language-taxonomy","title":"Programming Language Taxonomy","text":"<ul> <li>Compiled Languages v.s. Interpreted Languages + virtual-machine-based</li> <li>Static typing v.s. Dynamic typing</li> <li>Garbage collection v.s. manual resource management</li> <li>High-level v.s. low-level</li> </ul>"},{"location":"outline/#common-concepts-in-programming-languages","title":"Common Concepts in Programming Languages","text":"<ul> <li>Abstraction</li> <li>Interfaces &amp; ABCs &amp; Polymorphism</li> <li>Meta-programming</li> <li>find-replace-based macros</li> <li>generics</li> <li>Ownership &amp; lifetimes</li> <li>Error Handling</li> <li>try-catch</li> <li>Result</li> </ul>"},{"location":"outline/#other-abnormal-languages","title":"Other \"Abnormal\" Languages","text":"<ul> <li>LISP</li> </ul>"},{"location":"outline/#module-3-coding-properly","title":"Module 3: Coding Properly","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages</li> </ul> <p>This module explains the \"good practices\" and paradigms in programming, and more importantly, the logic behind them.</p> <p>After learning this module, you should get a good idea of how to design and code up large projects with hundreds of thousands of lines of code.</p>"},{"location":"outline/#common-coding-practices","title":"Common Coding Practices","text":"<ul> <li>Code Styling</li> <li>CODE_OF_CONDUCT</li> <li>Identifiers Naming Conventions</li> <li>Comments &amp; docstrings</li> <li>Testing (just mention some concepts)</li> </ul>"},{"location":"outline/#programming-principles","title":"Programming Principles","text":"<ul> <li>Syntax &amp; Semantics: What it can be v.s. What it should be (and usually be)</li> <li>Don't repeat yourself</li> <li>The rule of elegance</li> <li>Hierarchy</li> <li>Coupling &amp; Cohesion</li> <li>Depend on interfaces, not implementations</li> <li>Write comments</li> <li>When the program is short, forget about all principles</li> </ul>"},{"location":"outline/#programming-paradigms","title":"Programming Paradigms","text":"<ul> <li>Object Oriented Programming</li> <li>Functional Programming</li> </ul>"},{"location":"outline/#designing-software-systems","title":"Designing Software Systems","text":"<ul> <li>Modules &amp; APIs &amp; Interfaces</li> <li>Coupling &amp; Cohesion</li> <li>Other Considerations</li> <li>Abstract your dependencies</li> </ul>"},{"location":"outline/#module-4-terminal-superuser-basics","title":"Module 4: Terminal &amp; Superuser Basics","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages (recommended)</li> </ul> <p>This module introduces terminal, operating system basics and other \"superuser stuff\".</p> <p>This module should take you from a \"regular user\" who interacts with a computer by dragging-dropping and pushing buttons to a \"superuser\" who feels comfortable using terminals and doing multi-booting.</p> <p>Specific topics are listed below.</p>"},{"location":"outline/#terminal-shell-scripting","title":"Terminal &amp; Shell Scripting","text":"<ul> <li>What is a terminal? What is a shell? What is a shell script?</li> <li>Taxonomy of shell scripting languages: text-based (bash) v.s. data-oriented (powershell &amp; nushell)</li> <li>Key differences between scripting languages and programming languages</li> <li>Shell scripting basics</li> <li>Basic commands<ul> <li>cd, pwd, pushd, popd, find, ...</li> </ul> </li> <li>variables &amp; control flows, etc.</li> <li>commands</li> <li>pipes &amp; redirection</li> <li>environment variables</li> <li>Miscellaneous<ul> <li>&amp;&amp;, ;, $!, ...</li> </ul> </li> <li>Terminal Tricks &amp; Common Practices</li> <li>Auto-completion, history, etc.</li> <li>Shell config files</li> <li>Prompt-customization &amp; theming</li> <li>Shell plugins</li> <li>Common Tools &amp; Commands<ul> <li>grep, cut, awk, tmux, ssh, etc.</li> </ul> </li> </ul>"},{"location":"outline/#package-management","title":"Package Management","text":"<ul> <li>Software dependencies</li> <li>Software packages</li> <li>Package managers</li> </ul>"},{"location":"outline/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Config files</li> <li>vim &amp; emacs</li> <li>Virtualization &amp; docker</li> <li>Booting</li> <li>Hard drive partitions &amp; (g)parted</li> <li>Bootloaders &amp; GRUB</li> <li>BIOS &amp; UEFI</li> <li>Dual (Multi) Booting</li> <li>Linux potpourri</li> <li>kernel modules</li> </ul>"},{"location":"outline/#module-5-software-development","title":"Module 5: Software Development","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages</li> <li>Module 3: Coding Properly</li> </ul> <p>This module explains the common concepts and tools involved with software development.</p> <p>After learning this module, you should feel comfortable starting a large project, coding it up with a team, and publishing it to the public.</p> <p>Specific topics are listed below.</p>"},{"location":"outline/#common-concepts-in-software-systems","title":"Common Concepts in Software Systems","text":"<ul> <li>Versioning &amp; Dependencies</li> <li>Semantic Versioning</li> <li>Interfaces &amp; APIs &amp; Libraries</li> <li>Remote Procedure Call (RPC)</li> <li>Serialization &amp; Deserialization</li> <li>Inter-process communication (IPC)</li> <li>Frameworks</li> <li>What is a framework? Why framework?</li> <li>Framework v.s. Library</li> <li>Examples: Flutter (UI), PyTorch (deep learning) &amp; Unity (game development)</li> <li>Specification &amp; Standards (Use examples to illustrate the concept)</li> <li>Why standards?</li> <li>Examples<ul> <li>CPU Instruction Set Architectures (ISAs)</li> <li>GPU specifications (OpenGL &amp; Vulkan)</li> <li>Data Representation Standards (JSON, TOML, YAML, XML, HTML)</li> </ul> </li> </ul>"},{"location":"outline/#testing","title":"Testing","text":"<ul> <li>Unit testing</li> </ul>"},{"location":"outline/#documentation","title":"Documentation","text":"<ul> <li>Docstrings</li> <li>API Docs</li> <li>Tutorials</li> <li>Doctests</li> <li>Common documentation frameworks &amp; languages</li> <li>Sphinx &amp; mkdocs (just mention)</li> <li>Markdown &amp; RST</li> </ul>"},{"location":"outline/#building-deployment-tentative","title":"Building &amp; Deployment (tentative)","text":"<ul> <li>Build systems</li> </ul>"},{"location":"outline/#version-control","title":"Version Control","text":"<ul> <li>Version control &amp; git</li> </ul>"},{"location":"outline/#standardization-collaboration","title":"Standardization &amp; Collaboration","text":"<ul> <li>The need for standardization across contributors</li> <li>CODE_OF_CONDUCT</li> </ul>"},{"location":"outline/#cicd","title":"CI/CD","text":""},{"location":"outline/#miscellaneous_1","title":"Miscellaneous","text":"<ul> <li>PRs &amp; Issues</li> <li>README, CONTRIBUTE, LICENSE</li> <li>TODOs &amp; FIXMEs</li> </ul>"},{"location":"outline/#module-6-concurrent-programming","title":"Module 6: Concurrent Programming","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages</li> <li>Module 3: Coding Properly (recommended)</li> </ul> <p>This is a relatively stand-alone module that explains the concepts involved with concurrent programming.</p> <p>Topics are listed below.</p>"},{"location":"outline/#introduction-to-concurrency","title":"Introduction to Concurrency","text":""},{"location":"outline/#concurrency-model","title":"Concurrency Model","text":"<ul> <li>Concurrency v.s. parallelism</li> </ul>"},{"location":"outline/#problems-with-concurrency","title":"Problems with Concurrency","text":"<ul> <li>Data races</li> </ul>"},{"location":"outline/#low-level-concurrent-programming","title":"Low-level concurrent programming","text":""},{"location":"outline/#synchronization-primitives","title":"Synchronization primitives","text":"<ul> <li>Locks (Mutexes)</li> <li>Semaphores</li> <li>Read-Write Locks</li> </ul>"},{"location":"outline/#concurrent-programming-paradigms","title":"Concurrent Programming Paradigms","text":""},{"location":"outline/#channels","title":"Channels","text":""},{"location":"outline/#producer-consumer","title":"Producer &amp; Consumer","text":""},{"location":"outline/#asynchronous-programming","title":"Asynchronous Programming","text":"<ul> <li>Futures &amp; poll</li> <li>async &amp; await</li> </ul>"},{"location":"outline/#module-7-computer-architecture-fundamentals","title":"Module 7: Computer Architecture Fundamentals","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 1: The Abstract Computer</li> <li>Module 2: Programming Languages (strongly recommended)</li> </ul> <p>This module introduces the very basics of how computers work in hardware.</p> <p>After learning this module, you should have a deeper understanding of computers and be able to code programs that utilize the hardware in an optimized way.</p> <p>Topics are listed below.</p>"},{"location":"outline/#cpus","title":"CPUs","text":"<ul> <li>Pipelines</li> <li>Memory Hierarchy</li> <li>Branch Prediction &amp; Speculative Execution</li> <li>Out of order processing</li> <li>Vector instructions &amp; SIMD</li> </ul>"},{"location":"outline/#gpus-accelerators","title":"GPUs &amp; Accelerators","text":""},{"location":"outline/#module-8-miscellaneous-topics-in-the-developers-world","title":"Module 8: Miscellaneous Topics in the Developer's World","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages (strongly recommended)</li> <li>Module 3: Coding Properly (recommended)</li> </ul> <p>This section discusses the various fields and common tools in the developer's world.</p> <p>Topics are listed below.</p>"},{"location":"outline/#ui-app-development","title":"UI &amp; App Development","text":"<ul> <li>Declarative UI v.s. Imperative U</li> </ul>"},{"location":"outline/#game-development","title":"Game Development","text":"<ul> <li>Entity Component System (ECS)</li> </ul>"},{"location":"outline/#gpu-programming","title":"GPU Programming","text":"<ul> <li>High-level: OpenGL</li> <li>Low-level: Vulkan</li> </ul>"},{"location":"outline/#miscellaneous_2","title":"Miscellaneous","text":"<ul> <li>Stackoverflow</li> <li>GitHub</li> <li>IDEs</li> <li>LSPs</li> <li>Hugging Face</li> </ul>"},{"location":"outline/#module-9-ai-aided-development-ai-software-development","title":"Module 9: AI Aided Development &amp; AI Software Development","text":"<p>Prerequisite Modules:</p> <ul> <li>Module 2: Programming Languages</li> <li>Module 3: Coding Properly (Recommended)</li> </ul> <p>This module discusses how to use AI to develop better, and how to develop applications that take advantage of AI.</p> <p>Topics are listed below.</p>"},{"location":"outline/#artificial-intelligence-basics","title":"Artificial Intelligence Basics","text":"<ul> <li>Deep learning fundamentals</li> <li>Abstracting deep neural networks &amp; AI services for developers</li> </ul>"},{"location":"outline/#ai-aided-development","title":"AI Aided Development","text":"<ul> <li>Code-completion</li> <li>AI Code Generation (logic code, unit tests, documentation, etc.)</li> <li>Auto internationalization</li> <li>AI as an augmented Google</li> </ul>"},{"location":"outline/#ai-software-development","title":"AI Software Development","text":""},{"location":"outline/#a-change-of-mindset-how-is-this-different-from-traditional-software-development","title":"A Change of Mindset: How is this different from \"traditional software development\"?","text":"<ul> <li>Determinism -&gt; Non-deterministic behavior</li> <li>Structured Data -&gt; Natural Language</li> <li>AI involved control flows</li> <li>Short latency -&gt; long-running operations</li> <li>Error Handling &amp; How to ensure robustness when there is AI</li> </ul>"},{"location":"outline/#paradigms-common-practices-at-present","title":"Paradigms &amp; Common Practices at Present","text":"<ul> <li>AI Agents</li> <li>Retrieval Augmented Generation (RAG) &amp; Vector Databases</li> <li>Prompt Engineering &amp; Prompt templates</li> </ul>"},{"location":"abstract-computer/","title":"Module 1: The Abstract Computer","text":"<p>This module assumes that you know the fundamental ideas in the developer's world, specifically, abstraction, hierarchy and standards. If you don't, please take a look at Module 0: The Developer's Mindset before learning this module.</p> <p>This module introduces the various abstractions of computers applicable to developers, that is, what computers look like to developers. Understanding this is essential to understanding why programming languages are designed in the way they are and the logic behind their design choices, and it also helps you to understand what you can do or cannot do in coding, as well as the \"why\".</p> <p>In later sections, you will find that a lot of concepts introduced in this section (such as memory address space, stack and heap) apply to virtually all programming languages.</p> <p>Let's dive right in!</p>"},{"location":"abstract-computer/conclusion/","title":"Conclusion","text":"<p>In this module, we introduced some common abstractions for computers. The key takeaways are:</p> <ul> <li>Developers almost always target abstract computers to allow their programs to run on more computers, and to program complex applications more easily.</li> <li>The closest-to-hardware abstractions of computers are Instruction Set Architectures (ISAs). The common ingredients shared across most popular ISAs are registers, memory and instructions.</li> <li>Memory use cases, stack and heap are the basic models for using memory effectively.<ul> <li>Memory use cases defines what a piece of memory is for at each point in time.</li> <li>Stack is a small, ordered piece of \"buffer\" memory from which memory can be allocated and accessed quickly.</li> <li>Heap is a large, unordered piece of \"buffer\" memory that is generally slower to allocate and access memory from compared to stack.</li> </ul> </li> </ul> <p>Congratulations! You now have a basic understanding of how computers look like to developers!</p> <p>Developing the basic mindset and understanding how computers work is the first milestone in the journey of becoming a good developer, and you have made it!</p> <p>You can feel excited, as this marks the end of the \"prerequisite\" modules; starting from the next module, we will be discussing actual development, and you will start to get your hands dirty on coding!</p>"},{"location":"abstract-computer/isa/","title":"Registers, Memory and Instructions: Instruction Set Architectures","text":"<p>Instruction Set Architectures (ISAs) are the lowest-level abstractions for computers. ISAs are designed to be as close to hardware as possible, while being general enough to be applicable to the majority of computers. As such, ISAs are extremely human-unfriendly and few developers actually code with them directly, and higher level programming languages tend to abstract computers in a way completely different to ISAs. However, understanding ISAs provides a good starting point to understanding how computer hardware works, and it helps to explain a lot of design choices in higher-level programming languages and software applications, which is why they're introduced here.</p> <p>There exist multiple different ISAs, such as x86, ARM, MIPS and RISC-V. Each of them is designed a little bit differently (or quite differently, as in the case with CISC and RISC architecture families), but there are some concepts that are shared across almost all of them. These concepts are the fundamental abstraction that applies to almost all computer hardwares, and are covered in this section.</p>"},{"location":"abstract-computer/isa/#registers-memory-and-instructions-the-most-generally-applicable-abstraction-of-computers","title":"Registers, Memory and Instructions: The Most Generally-Applicable Abstraction of Computers","text":"<p>Virtually all ISAs employ the following concepts:</p> <ul> <li>There is a finite set of registers where you can hold data.</li> <li>There is a (virtually infinite) memory where you can hold more data. Each location in the memory can hold some data, and has an address associated with it; you use that address to access the data stored in that location.</li> <li>There is a \"processor\" that supports executing a finite set of instructions which modify the registers or memory in some way.</li> <li>Instructions are stored in memory and executed in order;</li> <li>There is a special register (usually called the \"program counter\", or \"PC\") that holds an address in memory; at each point in time, the \"processor\" reads the data at that memory address, interprets that data as an instruction, executes it, then updates the PC in some way.</li> </ul> <p>There are several important things to notice in the above concepts:</p> <ul> <li>Compared to memory, registers can only hold very limited amount of data. In most ISAs, the number of registers is less than 100, and the total amount of data that can be held in all registers is unlikely to exceed 1 megabyte (MB). On the contrary, memory is much larger: modern computers typically have anywhere from 4 to hundreds of gigabytes (GBs) of memory; even cell phones typically have 4 or more gigabytes of memory.</li> <li>What a computer will do starting from a specific point in time is completely determined by the data held in the registers (including the PC) and the memory. You can think of the registers and the memory as the \"state\" of a program; that state completely determines the program's behavior.</li> <li>The instructions supported by an ISA are generally very simple operations (CISC, or \"Complex Instruction Set Computers\", which is a family of ISAs support more complex instructions, but their functionalities are still extremely limited compared to complete computer programs), such as \"add up the data in register 5 and register 11, and store the result into register 0\", \"load the value at memory address 122 to register 1\", or \"move the PC 40 memory addresses forward\". These instructions are not complete computer programs; they are used as the building blocks of larger programs. By composing these simple instructions (called \"programming\"), one can create programs that do virtually anything.</li> </ul> <p>Why do we need registers?</p> <p>You might wonder why we need registers at all: both registers and memory serve as the \"state\" of a program, so why can't we use memory exclusively? After all, registers can only store very limited amount of data, while memory is much larger.</p> <p>The answer relates to how computer hardwares work. Although registers are small, they are very fast; on the contrary, memory is large but also slow (compared to registers). As a result, the typical practice is to store the data that needs to be accessed frequently in registers, and the rest of the data in memory.</p> <p>This is a good example of how ISAs are close to hardware, and as you can see, although abstractions are \"general and abstract characteristics\", they typically depend on and reflect the underlying objects which they apply to.</p> <p>Other ISAs</p> <p>Although what is introduced here is applicable to the vast majority of ISAs, there are ISAs that abstract computers differently. For example, WebAssembly (WASM) is a stack-based architecture which does not have registers.</p>"},{"location":"abstract-computer/isa/#how-are-computer-programs-run","title":"How are computer programs run?","text":"<p>Imagine a person with a pencil holding a notebook. At the beginning, the notebook is on a certain page; then, at each point in time, the person reads a page, does something (either do some calculations and memorize the result, or write something to another page) according to what that page says, changes to another page, and the same process goes on.</p> <p>That is a good analogy of how a program gets run on a computer: the person is the processor; the notebook is the memory, and the person's brain memory is the registers.</p> <p>As mentioned before, ISAs only support a very limited number of instructions with very limited functionalities; those instructions serve as the building blocks for larger software applications. Virtually every software application boils down to a large number (from hundreds to millions) of ISA instructions when it gets run on the computer hardware. Basically, the way programs run, as defined by the ISAs, is like the following:</p> <ol> <li>At the beginning, the memory and registers are initialized to some values. Typically there is a special segment in the memory which holds all the instructions; the instructions held in that segment are the \"program\".</li> <li>At each point in time, the processor reads an ISA-defined instruction at the memory address specified by the PC, executes it (either do some calculation and write the result to a register, or write some data to a certain memory address, etc.), and updates the PC (usually to the memory address of the next instruction, but could also be somewhere else).</li> <li>This process is repeated until the program is finished.</li> </ol> <pre><code>graph TD\n\n    start --&gt; read-instruction\n    read-instruction --&gt; execute-instruction\n    execute-instruction --&gt; update-PC\n    update-PC --&gt; read-instruction</code></pre> <p>What if there are multiple programs?</p> <p>You may have wondered, what if there are multiple programs running on the same computer? Since they use the same piece of memory, won't they interfere with each other? And, how are they executed? Are they executed one by one or at the same time?</p> <p>The short answer is, the operating system provides another layer of abstraction which eliminates all these concerns. In simple words, the operation system \"virtualizes\" the computer hardware and creates the illusion of multiple, independent computers running at the same time. each program is allocated such a \"virtual\" computer of its own; in the program's view, there is nobody else on this computer, so no interference at all.</p> <p>How the operation system creates that illusion, though, is out of scope of this section.</p>"},{"location":"abstract-computer/isa/#conclusion","title":"Conclusion","text":"<p>In this section, we talked about the lowest-level abstractions of computers: Instruction Set Architectures (ISAs). Compared to other abstractions of computers, such as higher-level programming languages, ISAs are closer to the hardware but also less human-friendly. Although developers typically use completely different abstractions when programming, understanding ISAs provides a good foundation of understanding how computers work.</p> <p>Virtually all ISAs have a set of registers, a memory and define a set of supported, simple instructions. One special register is called the program counter (PC). The way a program runs is basically \"fetch instruction at PC - execute instruction - update PC - repeat\". ISA instructions serve as building blocks for more complex software applications; virtually every software application boils down to a large number of simple ISA instructions when it gets run on the hardware.</p> <p>Congratulations, you now understand how computer hardware works! Real world computer hardwares are much more complicated than ISAs, but for now, ISAs are a good approximation to the real hardware.</p> <p>Next, we will introduce some higher level abstractions that build upon ISAs and are found in most low-level programming languages like C/C++ and Rust.</p>"},{"location":"abstract-computer/isa/#ai-prompt-samples","title":"AI Prompt Samples","text":"<p>If you want to learn more about the topics in this section, feel free to consult an AI such as ChatGPT.</p> <p>Here are some sample prompts to get you started:</p> <ul> <li>Can you briefly describe the ARM architecture, as well as its instructions?</li> <li>Can you give an example ARM assembly code and explain what it's doing?</li> <li>What are the differences between CISC and RISC?</li> <li>How do Instruction Set Architectures compare to a Turing machine? Why are there no registers in a Turing machine? Why are there registers in ISAs?</li> <li>What are the most popular Instruction Set Architectures nowadays?</li> </ul>"},{"location":"abstract-computer/memory-use-cases-stack-heap/","title":"Memory Use Cases, Stack and Heap: Basic Memory Management","text":"<p>In the previous section, we learned that in the abstraction of ISAs, the \"state\" of a program is completely represented by the registers and the memory (this is not entirely true, but you don't need to worry about that for now). That is, their contents completely determines the behavior of a program. And, since the memory is much, much larger than the registers, it is the primary storage where a program stores its state.</p> <p>However, ISAs didn't provide any guidance to how that memory should be used. Although this adds flexibility, it adds complexity as well. Typically, programs would need to know which memory address stores what value; if it assumes that a certain address stores a certain value, but that address was actually overwritten by a previous instructions, it will not work as expected.</p> <p>As software applications gets larger and larger, it becomes harder and harder to track which address stores what value manually, and to make sure that memory reading and writing works properly. This is called the problem of memory management.</p> <p>To address this problem systematically, people have proposed many different models of \"how to use memory\", such as ownership, automatic garbage collection, RAII (Resource Allocation Is Initialization), etc. We won't describe all of them here, but we will describe the shared concepts that almost all of them use or build upon. These concepts are memory use cases, stack and heap.</p> <p>It is important to note that these concepts are often abstracted away and don't show up explicitly in higher level languages, especially those with garbage collectors such as Python. However, understanding these concepts provides a good foundation of understanding how a program gets run at a low-level (same with ISAs).</p>"},{"location":"abstract-computer/memory-use-cases-stack-heap/#memory-use-cases","title":"Memory Use Cases","text":"<p>Memory use cases helps to answer the question: for a certain piece of memory (i.e., spots in memory corresponding to a set of memory addresses), at a certain period of time, what are the ways that it should be used? I.e., what is this piece of memory for, at each point in time?</p> <p>Memory Use Cases as Abstractions</p> <p>If you recall the definition of abstraction from the previous module, you'll find that memory use cases are abstractions as well: a memory use case defines what something (the memory) is (something you can use for a certain use case during a certain period of time) to someone (the programmer), disregarding all the irrelevant details.</p> <p>Although it seems like an obvious idea, memory use cases alone helps to solve a lot of problems in memory management, as it clearly states what \"should\" and \"shouldn't\" be done to a memory address.</p> <p>Before defining the use case of a piece of memory, programmers would stare at a piece of memory and just don't know what to do with it: Can I write data to it? What is the value stored here? Is it just some random bytes I can overwrite, or meaningful contents I should keep? Will any instruction later make use of this piece of memory? If I want to store some long-lasting thing here, will it get overwritten at some point? As a program gets larger, it becomes harder and harder to answer these questions, as that requires looking at every instruction in the program and see what it does with the memory.</p> <p>Memory use cases makes it much easier. After knowing the use case of a piece of memory, developers can have some assumptions about the valid ways to use it and what would happen if it's used in certain ways. For example, the developer may think: \"Okay, at this point, this piece of memory does not hold anything important, so I can write whatever I want to it. However, after operation A finishes, operation B would use this memory to store it's records, and anything I write here will be overwritten, so I gotta make sure that I don't read this piece of memory after operation B starts.\"</p>"},{"location":"abstract-computer/memory-use-cases-stack-heap/#some-terms-associated-with-memory-use-cases","title":"Some Terms Associated With Memory Use Cases","text":"<p>Below describes some terms associated with memory use cases, which you're likely to encounter in the developer's world.</p>"},{"location":"abstract-computer/memory-use-cases-stack-heap/#allocate","title":"Allocate","text":"<p>To \"allocate\" a piece of memory means to find a piece of \"free\" memory (i.e., a piece of memory that nobody is using) and purpose it for some use cases. After a piece of memory is allocated for some use case, it is considered not okay to use it for anything else.</p> <p>For example, in computer programs, it is common to allocate memory to store data, such as someone's birthday.</p>"},{"location":"abstract-computer/memory-use-cases-stack-heap/#deallocate","title":"Deallocate","text":"<p>To \"deallocate\" a piece of memory means to mark the end of the current use case (whatever it is) associated with it. After a piece of memory is deallocated, it is considered okay to be repurposed for any other use case, and not okay to use it for the previous use case.</p> <p>For example, if a piece of memory is currently storing someone's birthday and it's deallocated, it is then okay to use it to store the result of \\(153 \\times 13251\\), etc.</p> <p>The term \"deallocate\" is sometimes used synonymously with \"free\", or \"destroy\".</p>"},{"location":"abstract-computer/memory-use-cases-stack-heap/#stack-heap","title":"Stack &amp; Heap","text":"<p>Building on the concept of memory use cases, stack and heap are two special pieces of memory that creates a more well-defined model for memory management. Stack and heap are not for specific memory use cases (such as storing someone's birthday); rather, they are \"pools\" from which memory can be allocated in a well-defined way.</p> <p>You can think of the stack and heap as both being existent for the whole lifetime of a program.</p> <p>Stack &amp; Heap as Data Structures</p> <p>Stack and heap are also names for data structures. While they share some similarities with the memory objects introduced here, they are not the same things.</p> <p>For clarification between the \"stack memory object\" and the \"stack data structure\", the former is usually referred to as \"stack memory\", while the latter just \"stack\". Similarly, the \"heap memory object\" and the \"heap data structure\" are usually referred to as \"heap memory\" and just \"heap\".</p>"},{"location":"abstract-computer/memory-use-cases-stack-heap/#stack","title":"Stack","text":"<p>In terms of memory use cases, the stack is a special, typically smaller piece of memory which is used to store (roughly) \"things that are small and need to be quickly accessed\".</p> <p>Stack is Last-In-First-Out (LIFO) ordered, meaning that when you allocate memory from it, the newly allocated memory is on top of (i.e., its address always precede or follows) the last piece of previously allocated memory. Similarly, when you deallocate memory from it, the top most piece of memory is deallocated first.</p> <p></p> <p>Why is stack good for \"things that are small and need to be quickly accessed\"?</p> <p>Since the stack is usually small, it can only store small things. On the other hand, stack is good for things that need to be quickly accessed because it's ordered: as long as you know the sizes of the things after the thing you want to access, and the memory address of the top of the stack (i.e., the address of the last thing on the stack), you can easily compute the memory address of the thing you want to access and access it. In compiled languages such as C++, such memory address calculations are typically done statically at compile time, which means when the program is run, you get the address of anything you want to access on the stack with (almost) no calculations at all (for now, you don't need to understand how this works; just keep in mind that accessing things on the stack is easy and fast).</p> <p>Fun Fact</p> <p>Stack is small and its size is often fixed during a program's lifetime; when you try to use more memory than the stack can provide, you trigger an exception called \"stack overflow\", which happens to be the name of a platform on which developers talk about program errors and their fixes.</p>"},{"location":"abstract-computer/memory-use-cases-stack-heap/#heap","title":"Heap","text":"<p>In terms of memory use cases, the heap is a special, typically larger piece of memory which is used to store (roughly) \"large, long-lasting things\". Heap is typically much larger than the stack.</p> <p>Heap is unordered, which makes it harder both to allocate and access memory compared to stack. In stack, memory is always allocated on the top; in heap, however, you would have to first find a free piece of memory, then allocate it; when you want to access something, you must know its memory address, or you will have a very hard time finding it on the heap.</p> <p></p> <p>In computer programs, a typical combination is to store something really large on the heap, but keep its memory address on the stack. This way, you can store large things (like databases, cuz the heap is large) but also access them relatively quickly (cuz the stack is fast).</p>"},{"location":"abstract-computer/memory-use-cases-stack-heap/#conclusion","title":"Conclusion","text":"<p>In this section, we talked about the basic models for memory management, which are memory use cases, stack and heap.</p> <p>The key takeaways:</p> <ul> <li>Memory use cases defines what a piece of memory is for at each point in time.</li> <li>The stack is a small, ordered piece of memory which is fast and easy to access and allocate memory from.</li> <li>The heap is a unordered piece of memory. Compared to stack, it is slower to allocate memory from the heap, but the heap is much larger than the stack.</li> </ul>"},{"location":"abstract-computer/memory-use-cases-stack-heap/#ai-prompt-samples","title":"AI Prompt Samples","text":"<p>If you're interested in the topics of this section, feel free to consult and AI such as ChatGPT for more information.</p> <p>Some sample prompts to get you started:</p> <ul> <li>Please explain the difference between stack and heap memory.</li> </ul>"},{"location":"abstract-computer/why-abstraction/","title":"The Abstract Computer: Why do we need it?","text":"<p>Before learning any programming language, the first important idea to have in mind is that, except for extremely limited cases, developers always code for abstraction of computers and never target specific computer hardware. If you code in high-level languages like Python, you target abstract computers; if you code in lower-level languages like C, you target abstract computers; even if you write machine code directly (machine code are binary sequences like 00111001010100111 which, although barely readable for humans, can run directly on computer hardware), you are still targeting abstract computers.</p> <p>Why is this? Why do we need an extra layer of abstraction? Wouldn't it be simpler to code for hardware directly? There are two rationales behind abstract computers, as I will explain below.</p>"},{"location":"abstract-computer/why-abstraction/#the-need-for-standardization","title":"The Need for Standardization","text":"<p>As reflected in the example of ISA (Instruction Set Architecture) provided in the previous module, having a shared abstraction (a standard) across computers allows the same software to run on different hardwares, and the same hardware to run different applications. That is, the significance of abstraction is that it is shared across different computers and software applications.</p> <p>Without such a shared abstraction, software applications target specific computer hardwares directly, which means one software application can only run on one type of hardware, e.g., one specific CPU model like Intel Core i7 12700H. If we want to support different computers, we would have to code the software for each of them. Conversely, a computer can only run the software applications that specific targets it. As you can see, without a shared abstraction, software development is extremely difficult and unproductive, and the functionality of computers is extremely limited.</p> <p>By targeting abstraction of computers, however, things become much easier: as long as the computer share the abstraction which an application targets, the application runs on that computer; all computers that share the same abstraction will be able to run any software application that targets that abstraction, as illustrated below:</p> <pre><code>%%{init: { \"flowchart\": { \"curve\": \"linear\" } } }%%\ngraph TD\n\nSoftware-1 --&gt; ISA\nSoftware-2 --&gt; ISA\nSoftware-3 --&gt; ISA\n\nISA --&gt; Computer-1\nISA --&gt; Computer-2\nISA --&gt; Computer-3</code></pre> <p>For now, you can think of the lowest-level abstract computers as being Instruction Set Architectures (ISAs), which are standards that define what operations a computer must support, such as math operations like addition and multiplication. At present, there are hundreds or even thousands of CPU models, but there are only a few ISA families. The most ubiquitous ISA family is x86 and is supported on almost every laptop and PC (except for newer generation Macs). In this case, targeting a shared abstraction (like x86) can be thousands of times more productive than coding for each specific hardware.</p>"},{"location":"abstract-computer/why-abstraction/#abstraction-makes-coding-easier","title":"Abstraction Makes Coding Easier","text":"<p>Instruction Set Architectures (ISAs) satisfy the need for standardization. However, very few developers actually write assembly code (i.e., code that uses ISA-defined operations directly) or machine code (i.e., binary code defined by the ISA standard which can run on hardware directly). in modern days. The reason is, ISAs are the lowest level of abstraction which interface with hardware directly. As a result, it is barely human-readable, and it is very difficult to code large, complex applications with it. An example of assembly code (x86) might look like this:</p> <pre><code>push   %rbp\nmov    %rsp,%rbp\nlea    0xe4c(%rip),%rax\nmov    %rax,%rsi\nlea    0x2e7e(%rip),%rax\nmov    %rax,%rdi\ncall   1090 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;\nmov    0x2dff(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10a0 &lt;_ZNSolsEPFRSoS_E@plt&gt;\nmov    $0x0,%eax\npop    %rbp\nret\n</code></pre> <p>(complete disassembly is omitted for brevity; this only shows the most crucial part of the code)</p> <p>The function of the above code is to print \"Hello World\" to your computer's screen, but you don't need to understand how it does that. The key takeaway is that, coding for an ISA directly is anti-human.</p> <p>As a result, developers need higher-level abstractions that allow them to design, build and understand complex software systems with ease. Roughly speaking, those abstractions are exactly what higher-level programming languages are. For example, the above assembly code looks like the following in C++, which is a popular low-level programming languages (again, no need to understand what it's doing right now):</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>And the code that does the same thing looks like the following in Python, which is a higher-level programming language:</p> <pre><code>print(\"Hello World\")\n</code></pre> <p>As you can see, coding for higher level abstractions (programming languages) makes coding much easier. However, programming languages are not independent of each other, and they are not monolithic pieces; there are many abstractions that are shared across multiple programming languages. For example, almost all programming languages have the concept of variables and structs; low-level programming languages like C/C++ and Rust typically have the abstraction of stack and heap; object-oriented or multi-paradigm languages like C++, Java and Dart usually have the concept of classes, objects and interfaces. There is no need to understand what these words mean for now though, as we'll illustrate them in later sections and modules.</p> <p>Congratulations! You have learned about abstract computers and the rationales behind them. Next, we'll take a look at the lowest-level abstraction of computers which is shared across all Instruction Set Architectures (ISAs).</p>"},{"location":"developer-mindset/","title":"Module 0: The Developer's Mindset","text":"<p>Before diving into coding, it is beneficial to first understand the fundamental ideas behind the developer's world and develop a \"developer's mindset\", so that you understand not only how to code, but also why programming languages are designed in the way they are, and why you should code in certain ways instead of others. This is what this module is all about.</p> <p>This module may seem to have nothing to do with programming, but the ideas are universal and broadly applicable to almost everything in the developer's world.</p> <p>This module does not assume you have any experience with programming or have learned any other module in this course.</p>"},{"location":"developer-mindset/abstraction/","title":"Abstraction: The Developer's Way of Thinking","text":"<p>The single most important idea that every developer must have is abstraction, a fundamental concept underlying all software systems, hardware architectures, and essentially, all complicated things.</p> <p>Abstraction helps to manage the complexity of real world systems, to break down complex systems into simpler components and to allow both the creator and non-creators something to quickly understand \"what this thing is\". Abstraction is found in almost every aspect in the modern world, from software applications to hardware and even \"non-technical\" industries such as animated films. However, it is especially important to developers as they deal with and use this concept every day. Essentially, abstraction should be the second instinct of all developers.</p>"},{"location":"developer-mindset/abstraction/#what-is-abstraction","title":"What is \"abstraction\"?","text":"<p>Generally speaking, \"to abstract\" roughly means \"to define what something is to someone, disregarding all irrelevant information\", and that definition (\"what something is\") is called an abstraction.</p> <p>Abstractions are sometimes called \"semantics\" synonymously.</p> <p>Notice that some people may define \"abstraction\" differently, such as \"the abstract nature that is common to multiple entities\". Here, I'm splitting that definition into two parts: the \"abstract nature\" part is defined as abstraction; the \"common to multiple entities\" part is defined as \"standards\", which is a concept introduced in a later section.</p> <p>According to the definition above, there are a few important questions to ask when abstracting something:</p> <ol> <li>What is the \"thing\" to be abstracted?</li> <li>Who is that \"someone\"? How will he/she/it interact with the \"thing\"?</li> <li>What is this \"thing\", in that \"someone\"'s view?</li> <li>What information are relevant? What information are not? I.e., What does that \"someone\" need to know about?</li> </ol> <p>Notice that the answer to these questions are dependent to the \"target audience\" of the abstraction, i.e., the person (or the system) that will use the abstraction and interact with the \"thing\". If your audience changes, the \"thing\" might look different, relevant information might become irrelevant, and vice versa.</p> <p>Abstraction is not meant for other people only; sometimes (actually most of the time), the target audience will be yourself who is designing and implementing the thing to be abstracted.</p> <p>Although I gave a definition above, abstraction itself is an \"abstract\" idea which is very hard to define clearly, and there is no broadly-accepted definition. So, I will use an example to illustrate what abstraction really means.</p>"},{"location":"developer-mindset/abstraction/#an-example-of-abstraction","title":"An Example of Abstraction","text":"<p>When you're in a morning rush and you see a car, what first comes to your mind? Is it \"I can drive this thing around\", or chassis, engine, tires and fuel tanks?</p> <p>I believe most people's view would be the former. Of course, the latter view is also important, but it is irrelevant to you at the moment: you're in a rush, so all that matters to you is that you can drive a car to get to your workplace fast.</p> <p>Believe it or not, you have already created an abstraction in the example above. Let's break it down a little:</p> <ul> <li>Target of abstraction: The car.</li> <li>Target audience: You.</li> <li>What is this thing (\"abstraction\"): Something you can use to drive around and get to anywhere fast.</li> <li>Relevant information: You can drive this thing around. It's fast.</li> <li>Irrelevant information: It's made up of an engine, a fuel tank, a chassis, etc. It's 4.6 meters long and 1.6 meters tall, with a peak power output of 140 hp. Stuff like that.</li> </ul> <p>The explanation above should be easy to understand: the target audience is you, and the only thing you need to know is that you can drive a car around, so that's the abstraction.</p> <p>For workers at a car factory, however, the view would be different. The workers build cars; they do not need to know how to drive the car, but they do need to know the inner workings of a car so that they can build it. This time, we have:</p> <ul> <li>Target of abstraction: The car.</li> <li>Target audience: Factory workers.</li> <li>What is this thing (\"abstraction\"): Something made of an engine, a fuel tank, a chassis and a bunch of other stuff.</li> <li>Relevant information: Internal structures of a car.</li> <li>Irrelevant information: How to drive a car.</li> </ul> <p>As you can see, abstraction depends on the target audience. As the target audience changes, the definition of the target of abstraction can change, and previously relevant/irrelevant information can become irrelevant/relevant as well.</p> <p>Abstraction also depends on the role of the target audience. When you're driving a car, the abstraction of a car is \"something you can drive\"; when you're repairing a car, the abstraction starts including engines, tires, etc., because such details are now relevant to you.</p> <p>Therefore, it is always important to identify the target audience and understand what it will do with the target of abstraction, and then decide what information are relevant/irrelevant and abstract the \"thing\" to the audience.</p>"},{"location":"developer-mindset/abstraction/#terms-phrases-related-to-abstraction","title":"Terms &amp; Phrases Related to Abstraction","text":"<p>In the developer's world, you're likely to encounter some terms or phrases related to abstraction. Here are the meanings of some of them:</p>"},{"location":"developer-mindset/abstraction/#abstraction","title":"Abstraction","text":"<p>Depending on the scenario, \"abstraction\" can have 3 different meanings:</p> <ul> <li>The first meaning is \"abstract definition\" of an object, as defined in this section. The emphasis of this meaning is on \"what something looks like to someone\", but that \"what something looks like\" can be either simple or complicated, depending on that \"someone\";</li> <li>The second meaning is \"a simplified definition of an object, created by hiding the irrelevant details\". This meaning emphasizes that the \"abstraction\" is a simplified description which hides away the details.</li> <li>The third meaning is \"an abstract standard which is shared among many objects\"; the emphasis of this meaning is that the abstraction applies to potentially many objects.</li> </ul>"},{"location":"developer-mindset/abstraction/#abstraction-over","title":"Abstraction over","text":"<p>\"An abstraction over \\(A\\)\" means that \\(A\\) is the target of abstraction, i.e., the \"thing\" from which the abstraction is created and which the abstraction applies to.</p>"},{"location":"developer-mindset/abstraction/#abstract-away","title":"Abstract away","text":"<p>To abstract away \\(A\\) means to hide away the irrelevant details when creating an abstraction; \\(A\\) is that \"irrelevant details\". An example is \"Programming languages abstracts away many details in the computer hardware\".</p>"},{"location":"developer-mindset/abstraction/#highlow-level-abstraction","title":"High/low level abstraction","text":"<p>A high-level abstraction is a more abstract abstraction, whereas a low-level abstraction is a more concrete one. In other words, high level abstractions are typically simpler but also farther away to the actual object(s) that is(are) abstracted; low-level abstractions are typically more complicated but also closer to the target(s) of abstraction.</p> <p>For example, if the target of abstraction is a car, a high-level abstraction might be \"something you can drive\"; a low-level abstraction might be \"something that has an engine, a chassis and some wheels\" (yes, this is an abstraction too. Since every fuel-powered car has an engine, a chassis and some wheels, and that this definition hides away the inner workings of the engine, chassis, etc., it can be thought of as being \"abstract and general\" in some way).</p>"},{"location":"developer-mindset/abstraction/#what-does-abstraction-look-like-in-the-developers-world","title":"What does abstraction look like in the developer's world?","text":"<p>Although the car example illustrates the concept of abstraction, it seems to have nothing to do with developer stuff. Now, let's see what abstraction look like in real world software systems and code.</p> <p>Here's a source code fragment from KonnyakuGPT, an AI-powered anime subtitle generator (there is no need to understand the code):</p> <pre><code>def simple_split_subtitles(subtitles: Sequence[srt.Subtitle], max_duration: datetime.timedelta) -&gt; List[srt.Subtitle]:\n    \"\"\"Splits subtitles that are too long.\n\n    The splitting scheme is simple; sentences are LIKELY to be broken into pieces.\n\n    Args:\n        subtitles (Sequence[srt.Subtitle]): Original subtitles.\n        max_duration (float, optional): The maximum duration of each output subtitle, in seconds. Defaults to 10.\n    \"\"\"\n\n    new_subtitles = []\n    for subtitle in subtitles:\n        remaining_text = subtitle.content\n        current_start = subtitle.start\n        splitted_subtitles = []\n\n        while len(remaining_text) &gt; 0:\n            expected_text_length = math.floor(max_duration / (subtitle.end - current_start) * len(remaining_text))\n            actual_text_length = min(expected_text_length, len(remaining_text))\n            item_text = remaining_text[:actual_text_length]\n            item_duration = len(item_text) / len(remaining_text) * (subtitle.end - current_start)\n\n            splitted_subtitles.append(srt.Subtitle(\n                index=len(new_subtitles) + len(splitted_subtitles),\n                start=current_start,\n                end=current_start + item_duration,\n                content=item_text\n            ))\n\n            remaining_text = remaining_text[actual_text_length:]\n            current_start += item_duration\n\n        new_subtitles += splitted_subtitles\n\n    return new_subtitles\n</code></pre> <p>There is no need to understand what the code does and how it does its job for now. Basically, the code segment makes up a function (think of it as a tool you can use to do something) which can split up long subtitles into shorter ones.</p> <p>You may have noticed that there is some human-readable text at the beginning, namely the following:</p> <pre><code>\"\"\"Splits subtitles that are too long.\n\nThe splitting scheme is simple; sentences are LIKELY to be broken into pieces.\n\nArgs:\n    subtitles (Sequence[srt.Subtitle]): Original subtitles.\n    max_duration (float, optional): The maximum duration of each output subtitle, in seconds. Defaults to 10.\n\"\"\"\n</code></pre> <p>Such text is called a \"docstring\", which, as its name suggests, provides documentation for the function. Such a docstring serves as an abstraction to the user of the function, as it includes and only includes what the user needs to know: what the function does and how to use it. The rest of the function, i.e., everything after the docstring, are all irrelevant to the user even though they are the logic code that allow the function to work. The user only needs to know how to use the function; it does not care about how the function works internally.</p> <p>Abstraction is very important in this scenario, because it allows the user of the function to quickly understand only the things that it needs to understand. Without the docstring, the only way to see what the function does is to read and understand the code. While this is possible, it is much more time consuming than reading the docstring, and a bigger problem is, if the logic code changes, users would need to change the way they use the function, which will result in a lot of code modifications. With abstraction however, no matter how the logic code changes, as long as it maintains the interface (i.e., what the function does and how to use it) defined in the abstraction, the users don't need to change how they use the function at all.</p> <p>Abstractions are important not only to users of software systems, but to those who develop the system as well. When there are a lot of code involved in a software (e.g., KonnyakuGPT has roughly ~2,000 lines of Python code), it becomes hard to remember what each piece of code does. Without abstractions like docstrings, even you yourself will find it hard to understand the code you written previously; abstractions make it much easier to understand, organize and maintain the software you work on.</p> <p>Congratulations! You have understood abstraction, which is a concept fundamental to all programming languages and software development processes. Next, we will take a look at hierarchy, which is a way to manage complexity and an idea used in every aspect of the developer's world.</p>"},{"location":"developer-mindset/conclusion/","title":"Conclusion","text":"<p>In this section, we touched upon the most fundamental ideas which form the foundation of the \"developer's mindset\". Although these ideas seem simple, they underlie virtually everything in the developer's world, and for good developers, these ideas are typically second instincts.</p> <p>The key takeaways are:</p> <ul> <li>To abstract means to give a definition of something to someone, disregarding all information irrelevant to that \"someone\"; that \"definition\" is called the abstraction of that \"something\".</li> <li>A hierarchy is a tree of abstractions formed by grouping things together according to some rule, where the child abstractions relate to their parent abstractions in some way.</li> <li>A standard is an abstraction which is shared across multiple entities, and provides a unified way that allows different entities to interact with each other properly.</li> </ul> <p>Even though what you learned in this section may seem to have nothing to do with programming, it provides a solid foundation that allows you to understand the logic behind different design choices and tradeoffs in the developer's world. That is, it allows you to understand not only \"how\" to do things, but also the \"why\".</p> <p>You're on the right track, and you have made a good first step on the journey of becoming a good developer!</p> <p>In the next section, we will take a look at how computers are abstracted to software applications and developers; this forms the basis of all programming languages and all software development processes.</p>"},{"location":"developer-mindset/hierarchy/","title":"Hierarchy: A Way to Manage Complexity","text":"<p>The second most important idea following abstraction is the idea of hierarchy. Hierarchy is a way to manage complexity, and is found in almost every software application.</p>"},{"location":"developer-mindset/hierarchy/#what-does-hierarchy-mean","title":"What does \"hierarchy\" mean?","text":"<p>Broadly speaking, the idea of hierarchy is about grouping things together and forming a tree of abstractions; that \"tree of abstractions\" is called a \"hierarchy\".</p> <p>That's a very abstract definition, so let's look at an example.</p> <p>Suppose you are a college students and you have the following files for course assignments, PPT slides, etc.:</p> <pre><code>introduction-to-ai.pdf\ncalculus-assignment-1.pdf\nprogramming-assignment-2.py\nliterature-textbook.epub\nintroduction-to-ai-lecture-2.pdf\ncalculus-assignment-2.pdf\nprogramming-assignment-3.py\nliterature-review-article.epub\nintroduction-to-ai-project-outline.docx\ncalculus-final-exam-review.pdf\nprogramming-code-snippets.txt\nliterature-essay-draft.docx\nintroduction-to-ai-research-paper.pdf\ncalculus-quiz-answers.docx\nprogramming-tutorial-slides.pptx\nliterature-poetry-analysis.pdf\n</code></pre> <p>Man, that's a lot of files. And it looks messy, doesn't it?</p> <p>A natural idea would be to group them into folders, for example:</p> <pre><code>course-files/\n  AI/\n    introduction-to-ai.pdf\n    introduction-to-ai-lecture-2.pdf\n    introduction-to-ai-project-outline.docx\n    introduction-to-ai-research-paper.pdf\n  Calculus/\n    calculus-assignment-1.pdf\n    calculus-assignment-2.pdf\n    calculus-final-exam-review.pdf\n    calculus-quiz-answers.docx\n  Programming/\n    programming-assignment-2.py\n    programming-assignment-3.py\n    programming-code-snippets.txt\n    programming-tutorial-slides.pptx\n  Literature/\n    literature-textbook.epub\n    literature-review-article.epub\n    literature-essay-draft.docx\n    literature-poetry-analysis.pdf\n</code></pre> <p>That looks much better, right? Files for the same subject are grouped together, and this way, you can find what you need much more easily.</p> <p>That is the idea of hierarchy. Recall the definition of hierarchy: the idea of hierarchy is about grouping things together and forming a tree of abstractions. Here, we group the files together according to the subject they belong to. You might ask: \"where's the 'tree of abstractions'?\" Well, the above directory structure can also be represented using the following graph:</p> <pre><code>mindmap\n  root((course-files))\n    AI\n      introduction-to-ai.pdf\n      introduction-to-ai-lecture-2.pdf\n      introduction-to-ai-project-outline.docx\n      introduction-to-ai-research-paper.pdf\n\n    Calculus\n      calculus-assignment-1.pdf\n      calculus-assignment-2.pdf\n      calculus-final-exam-review.pdf\n      calculus-quiz-answers.docx\n\n    Programming\n      programming-assignment-2.py\n      programming-assignment-3.py\n      programming-code-snippets.txt\n      programming-tutorial-slides.pptx\n\n    Literature\n      literature-textbook.epub\n      literature-review-article.epub\n      literature-essay-draft.docx\n      literature-poetry-analysis.pdf</code></pre> <p>This looks just like the branches of a tree. Each node in the tree represents an abstraction, and the abstraction of the child relates to that of its parent. For example, the abstraction of the \"course-files\" folder might be \"all the files for the college courses\"; its children are \"AI\", \"Calculus\", \"Programming\", and \"Literature\", and each of these folders abstracts away \"all the files for a certain course\", which is a part of \"all the files for the courses\".</p> <p>Now that you have a rough understanding of hierarchy, let's look at some common types of hierarchies to understand the idea better.</p>"},{"location":"developer-mindset/hierarchy/#common-types-of-hierarchy","title":"Common Types of Hierarchy","text":""},{"location":"developer-mindset/hierarchy/#composition","title":"Composition","text":"<p>Composition is possibly the most common type of hierarchy. A composition hierarchy is a hierarchy where, in the tree of abstraction, the parent contains the children.</p> <p>The previous course files example is a composition hierarchy. In this example, \"course-files\" folder is the parent of \"AI\", \"Calculus\", \"Programming\", and \"Literature\" folders; the folder for each course is the parent of the files of that course. \"course-files\" contains the course folders; each course folder contains its files. That is, the parent contains the children.</p> <p>Another example is a car. On the highest level, a car consists of a car body, engine, chassis, and the wheels. Then, the car body contains doors and windows, the engine contains gears and cylinders, and so on.</p> <pre><code>graph TD\n\nCar\n\nCar --&gt; Car-Body\nCar --&gt; chassis\nCar --&gt; Wheels\nCar --&gt; Engine\n\nCar-Body --&gt; Doors\nCar-Body --&gt; Windows\n\nEngine --&gt; Gears\nEngine --&gt; Cylinders</code></pre>"},{"location":"developer-mindset/hierarchy/#general-to-specific-hierarchy","title":"General-to-Specific Hierarchy","text":"<p>Another common type of hierarchy is the general-to-specific hierarchy. In a hierarchy of this type, the parent generalizes its children, and its abstraction is the intersection of the natures of the children.</p> <p>For example, consider the following hierarchy:</p> <pre><code>graph TD\n\nCreatures\n\nCreatures --&gt; Plants\n\nPlants --&gt; Trees\n\nPlants --&gt; Grass\n\nCreatures --&gt; Animals\n\nAnimals --&gt; Insects\n\nAnimals --&gt; Mammals\n\nMammals --&gt; Humans</code></pre> <p>In this hierarchy, \"Animals\" is a type of \"Creatures\"; \"Mammals\" is a type of \"Animals\"; and \"Humans\" is a type of \"Mammals\", etc. That is, each child is a type of the parent, plus some characteristics specific to itself; the characteristics of the parent is common to all of its children.</p>"},{"location":"developer-mindset/hierarchy/#why-is-hierarchy-important","title":"Why is hierarchy important?","text":"<p>Hierarchy is important, because it allows a system to be abstracted differently at different levels, which makes it easier to design, understand and maintain.</p> <p>Suppose we want to design a car. Without a hierarchy, we would need to design every single part together, from every bolt on the steering wheel to every gear in the engine. As there can be tens of thousands of parts in the car, it would be very hard to keep track of all of them and make sure they all work together.</p> <p>When the car is malfunctioning, we would need to check every part to find the faulty one and replace it; if we want to explain how the car works, we would need to explain what each part does, and the fact the all the parts cooperate to make up a functional car would probably look like magic.</p> <p>With the idea of hierarchy in mind, we would split up the car into more manageable pieces. For example, we can have one team of engineers to work on the engine, another team to work on the chassis, etc. And the team that works on the engine may further split up the engine into smaller pieces to make sure they all work together. The team that works on the engine does not need to know how the chassis works (generally); and vice versa.</p> <p>When the car is malfunctioning, we would first check each high-level component to see if it works correctly, identify the faulty component, check all of its sub-components, until finally reaching the broken part; although this is a lot of work as well, it is much easier than checking through every bolt and gear. If we want to explain how the car works, we would first explain the function of each top-level components, and then explain how the sub-components work together and make up a functional high-level component. Obviously, it is much easier to explain the car this way than first describe what each screw does, and \"suddenly, the parts just magically become a working car\".</p> <p>In software development, \"replacing the faulty part\" roughly maps to fixing the faulty piece of code; \"explaining how the car works\" roughly maps to understanding how the software is made up, so that you know how to write code for it.</p> <p>As you can see, by decomposing complex systems and grouping things together, the idea of hierarchy allows people to manage complexity, and to design and understand complex systems effectively.</p> <p>Congratulations! You have now learned the idea of hierarchy. Next, we are going to talk about the last concept in this module: standards.</p>"},{"location":"developer-mindset/standards/","title":"Standards: Facilitating Interactions Between Entities","text":"<p>In the 18th century, guns were made by skilled gunsmiths; every gun made in this way was a unique object. This makes guns extremely expensive and hard to repair if broken, as the only way to fix it is to send it back to the gunsmith and have him/her repair his/her creation by hand.</p> <p>So, in the mid-18th century, a French gunsmith named Honor\u00e9 LeBlanc suggested that gun parts be made standardized. Standardized gun parts work with each other regardless of their creators; in this way, if a gun is broken, it can be easily fixed by replacing the faulty part with a new one.</p> <p></p> <p>Although Honor\u00e9 LeBlanc died a long time ago, his idea of standardization lives on, and became one of the foundations of modern software development.</p> <p>In this section, we will discuss the idea of standardization and its significance.</p>"},{"location":"developer-mindset/standards/#what-is-a-standard","title":"What is a standard?","text":"<p>Roughly speaking, a standard is an abstraction shared across multiple entities. Such a definition contains two parts:</p> <ul> <li>What is the abstraction?</li> <li>To what entities is the abstraction applicable?</li> </ul> <p>Standards are important, because:</p> <ul> <li>They provide a standardized way for multiple entities to interact with each other, and as long as the interaction adheres to the standard, it is \"guaranteed to work properly\"; and</li> <li>When designing something, depending on \"abstract standards\" is better than depending on \"concrete things\", as the former works with anything that adheres to the standard, while the latter works with only with a specific thing.</li> </ul> <p>Let's look at an example to understand the idea better.</p>"},{"location":"developer-mindset/standards/#an-example-of-standards","title":"An Example of Standards","text":"<p>One notable example of standards are Instruction Set Architectures (ISAs). An ISA is basically an abstraction of a computer, which defines what operations it must support, such as math operations like addition and subtraction.</p> <p>The previous definition of a standard applies to an ISA:</p> <ul> <li>What is the abstraction? The abstraction is the set of operations that must be supported, defined by the ISA.</li> <li>To what entities is the abstraction applicable? The standard (abstraction) is applicable to all computers that support the operations defined by the ISA.</li> </ul> <p>Why is this important? Well, have you wondered why software applications can run on different computers, made by different vendors and equipped with different CPUs? Each computer is different, and older computers and new ones likely don't have the same hardware, so why does the same application work on both of them?</p> <p>The answer is, a software application doesn't depend on a specific hardware; instead, it depends on a certain ISA. I.e., it only uses the operations defined by the ISA. As the same time, different computers can implement (i.e., support the instructions defined by) the same ISA. In this way, as long as a computer supports a certain ISA, it can run any software that targets it: the software only uses the operations defined by the ISA; the computer supports that ISA so that all ISA operations are guaranteed to work; therefore, the software is guaranteed to work properly.</p> <pre><code>%%{init: { \"flowchart\": { \"curve\": \"linear\" } } }%%\ngraph TD\n\nSoftware-1 --&gt; ISA\nSoftware-2 --&gt; ISA\nSoftware-3 --&gt; ISA\n\nISA --&gt; Computer-1\nISA --&gt; Computer-2\nISA --&gt; Computer-3</code></pre> <p>As you can see, an ISA serves as an \"agreement\" between software applications and computer hardwares; as long as the software and the hardware interact with each other in a way that adheres to the ISA standard (i.e., the software uses only the operations defined by the ISA, and the hardware supports the ISA), the software is guaranteed to work properly. Adhering the ISA standard brings tremendous benefits to both software and hardware developers: without an ISA, software developers would have to program the same software for every computer, whereas the ISA reduces that to programming the software only for a few ISAs; such benefits applies to hardware manufacturers as well.</p> <p>Congratulations! You have learned the idea of standards, which is the an important concept that underlies virtually all software applications.</p>"}]}